package LSDRadixSort;

import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.CountedCompleter;
import java.util.concurrent.RecursiveTask;

/*
 * https://github.com/openjdk/jdk/commit/618bdb5f8d2a4354462a886c854efbdfc97c6d48
 *
 * This code is free software; you can redistribute it and/or modify it
 */

public class LSDRadixSort {

    public static void main(String[] args){
        int[] a = {55546, 36416, 54618, 8188, 127470, 77374, 60100, 23960, 20823, 77128, 70303, 51385, 129765, 97713, 76559, 99719, 130876, 1868, 60648, 25051, 61175, 14367, 81999, 79637, 63982, 93270, 112544, 5420, 16060, 90490, 21650, 35590, 3707, 10466, 129945, 40969, 10449, 19817, 14731, 86769, 78896, 73824, 81798, 111075, 128600, 25030, 80144, 57282, 69920, 112566, 24702, 39618, 83830, 108832, 95642, 71738, 36516, 69563, 31360, 18877, 28628, 79162, 121544, 122730, 32214, 4029, 24809, 39811, 123679, 86410, 40412, 52028, 85012, 16380, 42751, 63701, 45449, 99771, 85564, 76522, 51075, 95277, 14442, 17673, 5189, 26667, 30194, 23941, 127882, 17911, 98741, 7305, 2574, 82030, 51757, 30831, 60755, 89977, 10450, 90962, 66465, 96713, 125886, 81377, 57421, 103874, 87443, 9078, 41022, 124343, 47004, 90982, 2732, 54104, 35378, 48026, 96811, 118376, 75616, 10334, 119272, 119474, 68554, 23928, 817, 121149, 115146, 81020, 59194, 43198, 121563, 56414, 28957, 47437, 39738, 63049, 97314, 8028, 15306, 117678, 113216, 111076, 124471, 55711, 100067, 122848, 53086, 60764, 106992, 59646, 5100, 28206, 71429, 93588, 80708, 127091, 120069, 100816, 99494, 26106, 47571, 127027, 25229, 98192, 5724, 112448, 116823, 5082, 126683, 52848, 77355, 106341, 97112, 20072, 28438, 78331, 109681, 71789, 124279, 89400, 47196, 30999, 92573, 129116, 62507, 115268, 5806, 118113, 97618, 69711, 63946, 99152, 96102, 44674, 69487, 22991, 57895, 118472, 78622, 35327, 19392, 34983, 58686, 24708, 58188, 21356, 68417, 25828, 44956, 94119, 3589, 8725, 60983, 62425, 64124, 25680, 56993, 28780, 100494, 65579, 97760, 89826, 76861, 95974, 63035, 118865, 103690, 68612, 51012, 69390, 81815, 8221, 125465, 10152, 64909, 124146, 30182, 101656, 104383, 48833, 34989, 19510, 61071, 59099, 30793, 33389, 15504, 9075, 36783, 2994, 89964, 43191, 56439, 105393, 84744, 30500, 118938, 112201, 2789, 117526, 48253, 15162, 62921, 29086, 91438, 31005, 128926, 71319, 15084, 64403, 71065, 57339, 62444, 100545, 102558, 60018, 102234, 66043, 18914, 31532, 1181, 7103, 85457, 129775, 74463, 73956, 43314, 3699, 91340, 13586, 60553, 90093, 48281, 51828, 444, 60905, 40007, 16044, 79865, 127836, 114216, 54023, 109014, 113913, 94626, 95217, 25017, 65475, 28722, 939, 123001, 99555, 97971, 72762, 59973, 16059, 24288, 97442, 48580, 72506, 120087, 38228, 72062, 75633, 116319, 59364, 45946, 55398, 45740, 11774, 67367, 101672, 3937, 31642, 40319, 40483, 83477, 53358, 78697, 101813, 88985, 52388, 90718, 11776, 99130, 31949, 110415, 53249, 74306, 28948, 74694, 118753, 1989, 103350, 120139, 70283, 122009, 94897, 130824, 84094, 4005, 61627, 37295, 2531, 115294, 37237, 23963, 73698, 96655, 54496, 80693, 36656, 38488, 22031, 54681, 14316, 56184, 41246, 64376, 73387, 33486, 128098, 105023, 111313, 108316, 90337, 51064, 108066, 1550, 130564, 97393, 76184, 24187, 74891, 124954, 41846, 61161, 58560, 31539, 78492, 55382, 76783, 70310, 103197, 26933, 85269, 123953, 14350, 38070, 57558, 4423, 44705, 6730, 12468, 1080, 106097, 74086, 106878, 129935, 129822, 19846, 53509, 92090, 80668, 36468, 88853, 130800, 108488, 78025, 31139, 109391, 72380, 127668, 128066, 46916, 113763, 73977, 4827, 121902, 104399, 61, 100253, 5957, 71625, 1664, 99378, 26808, 114985, 108777, 93746, 123157, 114280, 115145, 59100, 41198, 4211, 53977, 6659, 44728, 30913, 108486, 100421, 116470, 94375, 72943, 114819, 101014, 115178, 69229, 48268, 110490, 38038, 45907, 120091, 6138, 1549, 59702, 33027, 62152, 105826, 78831, 86952, 84885, 78055, 30111, 126641, 44051, 4356, 41715, 121595, 46075, 101450, 63400, 97488, 117552, 73927, 28497, 104280, 21028, 126619, 34392, 70479, 128122, 16331, 34626, 130296, 66029, 80212, 124982, 126288, 127343, 2435, 31935, 86663, 94869, 75651, 98256, 19371, 110897, 96311, 47624, 68518, 110400, 27722, 84023, 63338, 121094, 93059, 116257, 62314, 79735, 8541, 123265, 37963, 58585, 32470, 104784, 75483, 108454, 34183, 44358, 49985, 120758, 77812, 65953, 57206, 127389, 68389, 64292, 70899, 31826, 21877, 71522, 3500, 9488, 112297, 17724, 117820, 79232, 124227, 49575, 115553, 116759, 118040, 97458, 28841, 24253, 2848, 19143, 93805, 49071, 119437, 91696, 12542, 81061, 36638, 66781, 58142, 51254, 55476, 1635, 5554, 32123, 35877, 65096, 79540, 97779, 73039, 73341, 66414, 18854, 30320, 50731, 27108, 62860, 129205, 112818, 101777, 123950, 29200, 82157, 123734, 58509, 72782, 50363, 104623, 56131, 63848, 101563, 113191, 23016, 74008, 50262, 118029, 116918, 119727, 62977, 53352, 1648, 91685, 34755, 55591, 41598, 88945, 64501, 114076, 71004, 81691, 64072, 33835, 39733, 5390, 91404, 35134, 38091, 29362, 130735, 36987, 103065, 38202, 25475, 79161, 93754, 67898, 23491, 93743, 71179, 112507, 51671, 71790, 61199, 27410, 47319, 48529, 61715, 74926, 20301, 67890, 123154, 118578, 109118, 106911, 85466, 10627, 124011, 22477, 13038, 129442, 52692, 57996, 26030, 56572, 6013, 39164, 78005, 18944, 63347, 57407, 115074, 104178, 100625, 16495, 19545, 72191, 93567, 87250, 68203, 46736, 94331, 2892, 30260, 93154, 13659, 59156, 27172, 47318, 12370, 80554, 1409, 125189, 94194, 36104, 31627, 40727, 129777, 40471, 78048, 77909, 116271, 48740, 117538, 42363, 100087, 28179, 71382, 95442, 124292, 30483, 124814, 84350, 54215, 63122, 87626, 93204, 68711, 2483, 540, 41071, 130569, 4478, 14090, 36035, 42705, 115224, 73527, 130546, 9255, 94515, 90692, 40222, 64189, 22471, 120563, 125567, 23249, 113410, 76557, 37237, 58543, 77948, 107910, 27104, 45433, 29102, 26334, 47791, 42026, 29348, 117705, 102839, 83672, 45041, 54801, 17605, 112697, 59364, 114619, 28662, 93543, 45816, 7272, 1349, 117735, 110480, 77054, 16740, 57319, 13539, 84359, 39376, 45767, 114996, 99672, 129055, 67034, 104263, 61813, 120476, 95596, 81679, 74036, 4629, 18439, 122283, 120095, 99570, 28146, 39059, 127006, 49033, 95482, 96270, 6869, 94641, 29812, 97511, 112971, 22933, 79233, 122207, 71371, 52169, 72595, 105829, 125967, 10402, 102704, 128516, 107418, 53953, 130294, 81948, 65636, 97009, 99038, 87636, 68284, 54579, 71108, 107086, 92010, 68373, 40230, 18717, 32019, 98122, 13099, 76531, 3041, 46711, 48871, 43550, 72546, 96586, 93917, 93493, 25264, 99281, 120773, 102542, 36562, 87561, 48014, 64242, 2914, 129460, 113829, 117140, 12655, 53614, 33143, 67390, 164, 50434, 3125, 74444, 50857, 89849, 84694, 55518, 88265, 110452, 9057, 33992, 50132, 2107, 32876, 68813, 104006, 58901, 74207, 56717, 75944, 39769, 13821, 43195, 34870, 36804, 130725, 56082, 59329, 10637, 1748, 130441, 113366, 46007, 109677, 95684, 57120, 54693, 66108, 88526, 96266, 94195, 85560, 84741, 24744, 62082, 43016, 101461, 88023, 98260, 31688, 51112, 19106, 94619, 62732, 13981, 24807, 70284, 103972, 74359, 45113, 106871, 98209, 126807, 47368, 61852, 11288, 9902, 70143, 15414, 107557, 13548, 58797, 128860, 93874, 52861, 75367, 116233, 115065, 77813, 40043, 54649, 46534, 44425, 12872, 15286, 99713, 83393, 74621, 11121, 5227, 11115, 61792, 4373, 84391, 31442, 82497, 60697, 64892, 101935, 3791, 32661, 32601, 107872, 49593, 71960, 63513, 54487, 77208, 74936, 76935, 94164, 97547, 49001, 25635, 25046, 33059, 61586, 30758, 76622, 514, 88029, 85699, 30102, 62910, 25678, 18095, 94753, 115082, 92310, 22243, 96498, 59671, 73897, 124576, 39505, 53303, 31886, 106931, 71612, 94915, 50293, 118010, 63516, 79551, 92686, 122662, 11064, 15547, 72472, 25025, 61550, 119419, 59703, 89714, 95391, 125914, 105226, 121984, 56171, 50667, 31356, 78484, 75678, 71776, 13402, 78018, 46825, 96559, 105766, 26314, 83156, 120434, 93994, 2714, 108787, 10894, 87503, 82710, 50263, 118423, 121390, 121628, 86599, 69363, 1255, 41154, 102448, 58940, 51506, 128225, 61657, 66155, 101683, 85719, 85722, 30770, 25489, 47239, 21070, 116904, 117320, 100004, 64967, 73003, 66238, 119087, 38530, 122241, 87828, 28733, 89051, 66624, 123071, 98557, 49666, 120176, 42070, 112377, 9199, 56174, 71340, 64924, 8339, 85522, 89889, 77300, 5967, 83988, 60213, 122039, 30633, 93867, 10077, 33931, 120893, 61302, 28954, 36993, 2289, 63647, 38470, 68322, 103532, 69437, 95664, 128046, 91335, 124922, 103659, 99937, 98181, 42485, 114531, 125048, 68800, 41961, 688, 5683, 73125, 11150, 105518, 65563, 58914, 48959, 109517, 10182, 89565, 121308, 114724, 80984, 97383, 84209, 36812, 31565, 99505, 34071, 29675, 121206, 70590, 44186, 30734, 79937, 59034, 66652, 4924, 11069, 35722, 8952, 56903, 4572, 94852, 10793, 56165, 100729, 4321, 45677, 74494, 31644, 68688, 85221, 2503, 19581, 106766, 114559, 70670, 126406, 112467, 89942, 19031, 121245, 89103, 77144, 115496, 14817, 37077, 39208, 95777, 114610, 108311, 69190, 44111, 126775, 105108, 44909, 106944, 123802, 73485, 58428, 76890, 53079, 21822, 105752, 97256, 113846, 23308, 29008, 18293, 21141, 76538, 64385, 130013, 41323, 98017, 6203, 49056, 15497, 109024, 125668, 90105, 74657, 105872, 52444, 97071, 82060, 102012, 101089, 97322, 97607, 125904, 103605, 15176, 112190, 40527, 765, 88177, 68813, 49802, 38764, 41576, 24067, 86606, 6944, 8036, 57768, 29021, 114507, 101086, 79233, 20833, 91158, 89260, 88273, 123165, 59841, 44367, 23587, 47845, 61454, 35720, 51527, 67152, 108511, 38704, 67481, 82219, 39710, 128329, 82056, 74672, 36572, 61775, 34902, 5111, 58300, 57300, 85788, 56491, 6290, 71243, 89617, 105217, 86854, 68643, 124170, 6118, 70654, 63767, 23620, 119, 95868, 99524, 81505, 111030, 42435, 23419, 122544, 101241, 26113, 48216, 57265, 65189, 121000, 21651, 69079, 117404, 57053, 130069, 41615, 73203, 48662, 75598, 78721, 101992, 125693, 8773, 53781, 7187, 73371, 26864, 73528, 111578, 6578, 110789, 87903, 124201, 47721, 96144, 39627, 48867, 84014, 11143, 128527, 67475, 72151, 16539, 126671, 83174, 64010, 50960, 104649, 83549, 60895, 22351, 96025, 75582, 82371, 26362, 44472, 129995, 65695, 23361, 83781, 105910, 14648, 60531, 37639, 19411, 46552, 110296, 57138, 4367, 2606, 119997, 4969, 75424, 7026, 32207, 61316, 116093, 100044, 10156, 62098, 72464, 100854, 5047, 77345, 21802, 86559, 112171, 35260, 129335, 54546, 98930, 15029, 64178, 104599, 108727, 95267, 17626, 3097, 39097, 103214, 43942, 22664, 24034, 19337, 30709, 117376, 75928, 104512, 66313, 15019, 39122, 95411, 5430, 71778, 40429, 106977, 130006, 129690, 131007, 130025, 35455, 56061, 124140, 9166, 31607, 24407, 60024, 98682, 123752, 54579, 106653, 57861, 109647, 50117, 98527, 79414, 84922, 14346, 45404, 79177, 75826, 12078, 10600, 124914, 90613, 115501, 68441, 24482, 127720, 64955, 83870, 73224, 22987, 95592, 56598, 127194, 17582, 71935, 19103, 83412, 126627, 118063, 1516, 15104, 9396, 49261, 2971, 61240, 75287, 39192, 121990, 55017, 54175, 123357, 31832, 71961, 123510, 88156, 83299, 80042, 67081, 523, 107953, 36319, 17731, 76634, 72024, 87071, 126716, 46360, 128530, 20473, 123315, 21525, 56332, 20840, 72315, 42759, 122878, 71255, 48947, 83633, 115323, 86374, 71674, 78913, 51338, 121070, 11233, 84473, 2420, 16962, 62689, 37394, 83423, 93496, 89870, 42972, 39963, 50151, 34572, 34601, 44475, 78513, 125890, 28140, 68199, 72835, 100173, 111644, 127984, 53083, 824, 114142, 118693, 81162, 97257, 93154, 121060, 64571, 34653, 44556, 59635, 120243, 29463, 7255, 26640, 90585, 60757, 47606, 48070, 96889, 36229, 18107, 116353, 99524, 61431, 49852, 85093, 120731, 22738, 2099, 20826, 49676, 4684, 40870, 115819, 63004, 129557, 78407, 3152, 89030, 61971, 16029, 18761, 36932, 75861, 127842, 90156, 38284, 27200, 21679, 8897, 95773, 128782, 3926, 76109, 123130, 34169, 40590, 12652, 66038, 28850, 42965, 5667, 72242, 82072, 110866, 111925, 40164, 65830, 38137, 87477, 119897, 73004, 22962, 91100, 86844, 110657, 85437, 38428, 112152, 99319, 36623, 53109, 96539, 11344, 24705, 86790, 124444, 63345, 127338, 7398, 24286, 42133, 97162, 95284, 100245, 71235, 121641, 2668, 5546, 95171, 66943, 80892, 83643, 28110, 65878, 17942, 82917, 105092, 83437, 34247, 128325, 7330, 42015, 5193, 68026, 2547, 7620, 87188, 14064, 83207, 85847, 83514, 62874, 114210, 85977, 110964, 81406, 20343, 76532, 98423, 67766, 43158, 88418, 55820, 38836, 130337, 121743, 119135, 117638, 92870, 55933, 114454, 67802, 19048, 127719, 38821, 29253, 123039, 36521, 53984, 31295, 74082, 127070, 112849, 70002, 31491, 120138, 75723, 62771, 56410, 53626, 75710, 57936, 27205, 117289, 57037, 45067, 38991, 12902, 113437, 38758, 39086, 60914, 58864, 76449, 22387, 130670, 21489, 49409, 95484, 89781, 1745, 88786, 62380, 110726, 87058, 16813, 101598, 106598, 83233, 59646, 123158, 74692, 25770, 53952, 63353, 128349, 101672, 31882, 49278, 62434, 36026, 104655, 102374, 18135, 45629, 71777, 49641, 28093, 38806, 116791, 130993, 40307, 113999, 34671, 120587, 69592, 117605, 88469, 104795, 10677, 35679, 55589, 112081, 105178, 61346, 118350, 66266, 56454, 48131, 60920, 43736, 45579, 107422, 66824, 110612, 102322, 126949, 5090, 15347, 68571, 1275, 7727, 11623, 48744, 87874, 45792, 105128, 78428, 42546, 28785, 80420, 118206, 36972, 2418, 124596, 54211, 54542, 36162, 111375, 58667, 120392, 63773, 16515, 107243, 78127, 87385, 85217, 87819, 98001, 123628, 109496, 116689, 37513, 73009, 7878, 39199, 51603, 103403, 49579, 122905, 81890, 57737, 64736, 118026, 130608, 82347, 78822, 36744, 30039, 101349, 41666, 121045, 121567, 104130, 73384, 106631, 15063, 83722, 110069, 3947, 21224, 53063, 11106, 46247, 101030, 58246, 92278, 92446, 40233, 124250, 33596, 99607, 51164, 85029, 90934, 19488, 37524, 52634, 102801, 111408, 34020, 68221, 123033, 58635, 89263, 115629, 38510, 10474, 39421, 121700, 69368, 3930, 95250, 108220, 67863, 2404, 101308, 21364, 70431, 52717, 126701, 91636, 51843, 78176, 16776, 103310, 58063, 21385, 73599, 32006, 10203, 18372, 3101, 68947, 126781, 39766, 33440, 32935, 109823, 24090, 64522, 22445, 40849, 102751, 130616, 113425, 116480, 8464, 34867, 70468, 105320, 51990, 28613, 55424, 13991, 39161, 33871, 57098, 124243, 118733, 101081, 107446, 86765, 96843, 26475, 89264, 116054, 61757, 67482, 53880, 72577, 67103, 57957, 17710, 33641, 46083, 74049, 57871, 6981, 96949, 116337, 101695, 61947, 116766, 25755, 968, 6865, 5101, 15256, 104930, 51306, 102771, 52875, 72052, 41711, 105422, 83764, 99547, 52619, 81993, 14982, 115177, 85789, 35586, 41590, 94511, 119337, 96717, 8469, 95615, 126990, 47448, 123104, 61356, 31614, 37007, 42583, 111251, 32297, 40514, 124619, 95070, 122299, 85252, 63612, 80391, 56329, 8532, 45027, 54811, 59014, 17922, 65099, 23488, 26875, 64203, 91557, 126201, 38775, 117062, 21917, 21287, 91011, 41988, 50664, 77010, 69786, 21489, 41439, 111529, 7127, 120832, 121169, 89799, 92912, 105223, 76436, 124215, 128610, 107495, 63965, 25786, 25325, 9199, 117201, 110791, 15939, 1921, 76123, 3538, 119547, 93430, 76480, 56529, 51147, 9662, 112623, 64251, 65014, 42444, 22557, 55762, 25347, 1328, 14993, 103267, 108975, 129028, 105148, 32460, 73251, 123020, 53644, 67839, 2409, 24473, 43009, 54724, 22556, 67373, 48895, 27908, 96351, 4964, 8294, 63555, 41744, 19857, 85343, 119918, 1084, 97703, 24057, 64470, 95956, 3546, 67059, 101500, 51105, 50309, 103131, 126606, 45941, 112717, 79703, 89905, 70818, 123527, 79810, 58241, 127920, 62422, 117754, 124885, 28489, 85784, 51831, 69447, 110456, 20099, 94368, 128883, 88082, 79626, 121945, 62589, 11891, 97797, 2784, 2393, 58990, 83216, 94425, 41030, 19070, 77874, 98214, 116634, 78656, 64065, 44028, 63173, 549, 27525, 51635, 106383, 37730, 38556, 53468, 4004, 56108, 98204, 90136, 26193, 107041, 37246, 36903, 41616, 5385, 34233, 60607, 68929, 7101, 107053, 42654, 33722, 43878, 94530, 86754, 26241, 34795, 88145, 117656, 12375, 75940, 110658, 66962, 63865, 46163, 83061, 126844, 92961, 84051, 89061, 110129, 59218, 65297, 45195, 51786, 59605, 92603, 129280, 74488, 122750, 28984, 59493, 113171, 68787, 119383, 51334, 44402, 74798, 108874, 4669, 61820, 111873, 114773, 43028, 41215, 106202, 38337, 38702, 128576, 71560, 19735, 98918, 16722, 1213, 65418, 72632, 94123, 110101, 73652, 85983, 129267, 68439, 124037, 67648, 17695, 78585, 61303, 42758, 122814, 109801, 107014, 106893, 3219, 44426, 120415, 56579, 37219, 97532, 61271, 110924, 51471, 102048, 95134, 112166, 21476, 68827, 43060, 114318, 129329, 122137, 56859, 42593, 36377, 24596, 26445, 54853, 62891, 94805, 26352, 106953, 101935, 94458, 127175, 123850, 40898, 18106, 76780, 97561, 40997, 50470, 93371, 104794, 24529, 118321, 31249, 122414, 29774, 4594, 29110, 59540, 29636, 91303, 65559, 48268, 120273, 61693, 122680, 2812, 101789, 117389, 119016, 94679, 45356, 107690, 34869, 6780, 115187, 110937, 79394, 88667, 92845, 126112, 44439, 80350, 50798, 88067, 86680, 1413, 34040, 125515, 18617, 85331, 98380, 79753, 38097, 63080, 38788, 71001, 9709, 82671, 58079, 114539, 129415, 62522, 38173, 81983, 118520, 60202, 7693, 8751, 73258, 60116, 25187, 109746, 17809, 90464, 7375, 12766, 9051, 23348, 113738, 12334, 101861, 1106, 21426, 85125, 89969, 89086, 93849, 26739, 67862, 130724, 57177, 22710, 57591, 10743, 55915, 65538, 40887, 24413, 127736, 53764, 114988, 18569, 117936, 66212, 48210, 49769, 38619, 58762, 83585, 78403, 42157, 82404, 71138, 35098, 46813, 40549, 120607, 39254, 51832, 117136, 19033, 41635, 33010, 8757, 113503, 14360, 95613, 91195, 18715, 124060, 70557, 64928, 110671, 78213, 49916, 77758, 101761, 127873, 31866, 32975, 84532, 65977, 72840, 16819, 76120, 47923, 67254, 76784, 75522, 130679, 61065, 89081, 106335, 30581, 121233, 76722, 61670, 92069, 44731, 45363, 36300, 19568, 59107, 124364, 78013, 67534, 78509, 112968, 75976, 93999, 10645, 38262, 61594, 25759, 22083, 71140, 99566, 56868, 13347, 129005, 77380, 98154, 127541, 34550, 45520, 108961, 3873, 67828, 7605, 75174, 74382, 61232, 107634, 117856, 26547, 53070, 15260, 53612, 122157, 26763, 61901, 103420, 3603, 80197, 77788, 6652, 55367, 26816, 88398, 104821, 115726, 67878, 32779, 111670, 114915, 128463, 73556, 84400, 88967, 53699, 4596, 802, 115036, 125564, 14261, 130549, 9459, 66287, 32277, 79976, 22499, 84685, 81977, 42095, 44508, 67077, 78370, 66776, 31995, 108686, 84766, 129200, 118623, 92770, 25472, 121060, 6651, 104397, 31123, 85034, 68781, 74215, 53707, 111905, 118672, 78686, 91709, 122551, 16781, 118136, 88400, 35530, 68664, 45399, 90036, 50961, 41177, 72063, 21907, 11325, 29383, 67477, 94983, 93019, 66300, 76393, 54219, 118139, 37094, 41014, 17972, 35222, 99451, 6440, 103777, 70828, 58767, 7709, 49841, 118829, 29801, 32687, 123509, 47769, 79763, 78194, 102374, 1642, 37616, 71033, 11353, 47921, 80916, 97311, 89520, 115966, 40911, 89091, 32787, 5636, 36107, 99924, 130784, 48765, 14551, 88910, 51423, 7883, 61379, 115459, 21434, 104415, 2157, 28254, 58027, 89566, 60252, 107620, 66679, 20737, 82956, 73661, 31898, 188, 44873, 49267, 3011, 81186, 31424, 5624, 52098, 121479, 84434, 1389, 69951, 35686, 111531, 4129, 3182, 128133, 11923, 65111, 37888, 24406, 121987, 62027, 55068, 110240, 68859, 75639, 124174, 96606, 100370, 123410, 82047, 94183, 128718, 86745, 127462, 28494, 64693, 29456, 118078, 59147, 120484, 72907, 57081, 95450, 103134, 58217, 13364, 56035, 79463, 28769, 29227, 46106, 25491, 92224, 127214, 35560, 87513, 72690, 85332, 79371, 18156, 35391, 42544, 40889, 102668, 30104, 63682, 23307, 74392, 37396, 20592, 109465, 71400, 69556, 48565, 123745, 34905, 1262, 84057, 15084, 61352, 32105, 86242, 34739, 107651, 78084, 5450, 29886, 21341, 75548, 85233, 74125, 31873, 51726, 69589, 84796, 86121, 12026, 31999, 25569, 32080, 103882, 119872, 80952, 115206, 91506, 128797, 74626, 23042, 75896, 34055, 41385, 38589, 85431, 67279, 77735, 80445, 110943, 56664, 102953, 91887, 78399, 59277, 47727, 80058, 55110, 70549, 86389, 23376, 84294, 85829, 20823, 78278, 107771, 35798, 86257, 25446, 59724, 116951, 91589, 123332, 99792, 23140, 114721, 113678, 52627, 122520, 91521, 21416, 21017, 103999, 109873, 50680, 92834, 5328, 90934, 106365, 93103, 97177, 46446, 76838, 86724, 111676, 20214, 129249, 125552, 89689, 17867, 88689, 109194, 91276, 114355, 68996, 121020, 27802, 27485, 17412, 44357, 38630, 83655, 111533, 32762, 82217, 13279, 96735, 16781, 114785, 25197, 59572, 115985, 83466, 106031, 102741, 40381, 91275, 60485, 8073, 38127, 124659, 72399, 55950, 64628, 126948, 9940, 57132, 24838, 103375, 40037, 26374, 24853, 25185, 21762, 110899, 109514, 37692, 14395, 90124, 27720, 117225, 58010, 24647, 107828, 107789, 22208, 44356, 16503, 101595, 72909, 100006, 55106, 29898, 95237, 60198, 95826, 33927, 96943, 93347, 57972, 121899, 94272, 45436, 74059, 59312, 95673, 14114, 84561, 128417, 28748, 76264, 58395, 66833, 127557, 91677, 86496, 130765, 85544, 63068, 5435, 52692, 14357, 41761, 59439, 2823, 104820, 92063, 62316, 12316, 96973, 122833, 42192, 34264, 75767, 975, 125488, 16765, 62068, 50274, 54359, 99712, 79387, 23770, 58958, 80254, 33783, 93726, 103645, 126321, 71535, 14083, 47697, 80926, 129446, 32225, 640, 24785, 30500, 130915, 37642, 128076, 52149, 30367, 29665, 1276, 75921, 103014, 97290, 65134, 30909, 27612, 116388, 70657, 34736, 86602, 128041, 74459, 93752, 50, 113651, 81696, 27038, 101795, 102914, 24673, 33032, 46031, 25852, 123218, 105758, 13786, 47220, 50880, 62960, 33524, 40814, 449, 129815, 58793, 23330, 8492, 72217, 119927, 107008, 9803, 1810, 79776, 119540, 28879, 93071, 47170, 104683, 128515, 8125, 93348, 49812, 79684, 20930, 95697, 86634, 109488, 81770, 90731, 68338, 102686, 26118, 27320, 64321, 88141, 85136, 121345, 53185, 73823, 85011, 80155, 125748, 128391, 64073, 3653, 35831, 116481, 72325, 83509, 98699, 18498, 80083, 105068, 79441, 12657, 21341, 100561, 70036, 103189, 13839, 45182, 30157, 78094, 27774, 108500, 57121, 6345, 126469, 40916, 58925, 124591, 59441, 26801, 11014, 93917, 19294, 43936, 27771, 48410, 64929, 93683, 20380, 40965, 55273, 78181, 39807, 78734, 119136, 17847, 60737, 7847, 130326, 73595, 75851, 30778, 81377, 51247, 75478, 100188, 119934, 113549, 28336, 53955, 76795, 50720, 126527, 78709, 34905, 47386, 1478, 122562, 97132, 67428, 90343, 105332, 17414, 40951, 91240, 104004, 31572, 104810, 78905, 35214, 46215, 99019, 38325, 11336, 127670, 93617, 12840, 7216, 6402, 1425, 64913, 46916, 47354, 84048, 50600, 104567, 123713, 46106, 11554, 43937, 56942, 130673, 38706, 3254, 59443, 108680, 51027, 9786, 25792, 1233, 80196, 49908, 73833, 33236, 95572, 67297, 34693, 20034, 124127, 99179, 63641, 43594, 125719, 56027, 103606, 31274, 17927, 42763, 12831, 126472, 130005, 104286, 87342, 21250, 22599, 63988, 21367, 90498, 48776, 74778, 1325, 40151, 86826, 93696, 43204, 38913, 115310, 112045, 122072, 78795, 108227, 40246, 119885, 76319, 21388, 63533, 75958, 31381, 2086, 7256, 61178, 35916, 53033, 2467, 62004, 6397, 101868, 105814, 14555, 13645, 2126, 17546, 14371, 68193, 56500, 123353, 88481, 5303, 48205, 55892, 112437, 64564, 25500, 97721, 78115, 88440, 71479, 81381, 17027, 64633, 108748, 92551, 79835, 100431, 18532, 24086, 109578, 96332, 108011, 91396, 28519, 123471, 9967, 45107, 15657, 100953, 13480, 10664, 123656, 72544, 58936, 68222, 48932, 104803, 35634, 93468, 47142, 90302, 55904, 20138, 70564, 83647, 51392, 111552, 118474, 44920, 19664, 124000, 89397, 44246, 37387, 127782, 61986, 97010, 90290, 66493, 112583, 60839, 48591, 66709, 104704, 107363, 1910, 53202, 33070, 4418, 4430, 59271, 79452, 113752, 1359, 82211, 78242, 13390, 68812, 119851, 72142, 41775, 66996, 57385, 115776, 1667, 51220, 73188, 122900, 91549, 49119, 85968, 44934, 39217, 57073, 124359, 29586, 96297, 76625, 43001, 93659, 32184, 28086, 105761, 40141, 81070, 50252, 106489, 103941, 13326, 7607, 22511, 74479, 55517, 57432, 35097, 33712, 125244, 82382, 61285, 97351, 89273, 4798, 71956, 102382, 34273, 727, 62568, 69318, 14617, 41232, 66715, 55730, 3245, 39988, 29203, 130, 67113, 67487, 92628, 40532, 84199, 108617, 98358, 104502, 104937, 36355, 68311, 74256, 52456, 97537, 107986, 11712, 28332, 125848, 88112, 75910, 82078, 38983, 68510, 43682, 88475, 130043, 19296, 64828, 65546, 72846, 97925, 105091, 37168, 33680, 69980, 3095, 68034, 89418, 82470, 117675, 955, 66559, 99596, 68070, 81264, 97141, 111443, 32650, 64993, 106675, 31181, 44247, 125521, 4619, 113298, 76593, 8471, 4954, 54768, 62720, 44470, 127630, 3743, 51159, 109099, 45160, 97593, 66775, 41350, 61826, 83688, 45909, 1980, 97171, 2912, 100794, 121530, 115442, 114192, 73899, 49341, 85080, 24211, 111721, 14304, 59113, 83052, 71801, 109302, 66165, 61938, 49543, 98202, 42490, 41609, 2438, 29059, 51821, 2066, 4636, 53020, 7609, 60324, 59709, 27475, 94727, 107899, 119829, 88240, 89408, 41008, 58411, 49578, 117967, 23338, 15043, 29237, 37291, 41044, 106115, 59039, 10388, 57616, 83800, 62364, 17052, 61034, 66714, 88991, 119272, 32912, 74093, 124266, 40632, 82306, 43883, 51176, 43172, 20229, 65407, 32570, 120871, 92125, 49427, 89871, 50273, 79930, 40813, 95800, 102680, 96626, 36182, 38779, 10495, 55536, 20220, 105382, 88123, 121452, 33305, 78055, 35618, 76124, 99411, 117595, 13637, 69033, 121829, 101092, 74928, 63397, 1663, 10814, 83311, 87869, 119403, 19284, 39252, 78442, 108016, 46288, 92152, 12013, 22779, 87280, 60158, 66363, 34042, 73120, 129694, 98997, 28427, 69060, 97889, 47387, 127062, 130004, 42537, 51522, 182, 128430, 77684, 99077, 116638, 84390, 15073, 124025, 87866, 36066, 30194, 129636, 30164, 13029, 40210, 119790, 6521, 100968, 104922, 97689, 96731, 13168, 115087, 79726, 121977, 25244, 63471, 23160, 32509, 99775, 113196, 41334, 17380, 7598, 87608, 51403, 66915, 57690, 119363, 47545, 45705, 32288, 18561, 46286, 39584, 35167, 47920, 12189, 101081, 96075, 42201, 22961, 107047, 43776, 116949, 97470, 65386, 62426, 67602, 109594, 44496, 68611, 81431, 30570, 95096, 60492, 27205, 38048, 26199, 2368, 108895, 111908, 93023, 118134, 49995, 129617, 989, 58663, 20761, 113954, 68898, 77567, 114500, 105772, 22117, 91703, 45112, 2767, 78055, 55779, 99092, 49320, 89688, 50568, 66224, 122953, 377, 7921, 98529, 108076, 29954, 126274, 123387, 59620, 76997, 97613, 89239, 120724, 66834, 67364, 61845, 109477, 107613, 39150, 122980, 82355, 119582, 23294, 39808, 118215, 60920, 33057, 316, 7883, 54813, 32055, 56513, 9530, 1008, 18180, 127830, 110870, 106475, 118087, 74209, 39711, 116162, 123916, 20141, 118081, 21960, 83006, 78700, 122445, 63634, 94335, 82816, 79084, 80089, 37692, 78453, 58831, 120740, 43515, 122578, 49451, 48806, 102903, 42257, 17252, 79076, 51693, 89834, 89352, 14746, 64824, 37591, 83454, 76127, 44059, 38868, 53246, 70023, 34141, 45415, 60483, 87496, 83227, 92127, 88191, 35871, 11481, 106720, 42767, 45812, 26841, 15390, 5744, 9596, 63152, 14439, 60400, 62046, 123157, 107751, 17832, 30873, 58620, 123559, 104361, 93860, 54243, 129622, 84084, 47062, 18282, 2636, 8368, 109576, 96809, 69835, 98838, 46456, 22973, 38535, 104879, 92399, 75300, 130408, 321, 97318, 78410, 96141, 33798, 15973, 39395, 60052, 64159, 30573, 65659, 82712, 29255, 53400, 44490, 64634, 70475, 76861, 39757, 57572, 96953, 102233, 83729, 17803, 97111, 98667, 90065, 18227, 96727, 67230, 40515, 117496, 55368, 38957, 24494, 18250, 74958, 114434, 54720, 104760, 65429, 13473, 57245, 92658, 60418, 110148, 122939, 59528, 98603, 46662, 9708, 121847, 109961, 79812, 112444, 20838, 66028, 106624, 39164, 27308, 79790, 113929, 57758, 4374, 91691, 45848, 11715, 36966, 39792, 114237, 84498, 24093, 52273, 103098, 9803, 102653, 20224, 35503, 91547, 117960, 87740, 374, 8241, 42574, 8263, 98640, 109072, 115622, 116603, 42816, 29479, 15547, 63325, 57655, 21662, 65546, 59795, 27248, 122738, 16297, 26899, 10781, 98371, 10890, 117789, 22595, 35948, 95744, 6506, 3298, 101460, 31619, 52389, 7512, 22275, 126639, 60954, 125958, 119544, 28562, 94637, 69171, 28728, 32038, 4364, 60464, 110506, 35868, 70952, 114621, 19362, 83419, 115424, 38059, 120251, 13255, 24319, 12226, 122345, 88774, 130408, 65508, 128717, 35583, 102287, 32114, 76619, 92132, 58923, 39917, 47449, 93298, 105001, 12768, 75290, 94135, 69859, 97021, 130858, 28052, 3985, 6278, 122171, 104388, 102911, 13294, 97248, 127772, 120960, 42943, 129704, 1300, 123170, 21182, 105327, 21893, 49186, 63820, 102895, 116915, 101282, 22798, 47261, 71054, 118425, 21200, 16050, 56373, 112394, 85670, 41863, 8378, 29560, 15956, 37669, 77356, 29592, 123375, 30748, 75217, 32840, 78531, 54931, 48819, 122560, 71799, 50336, 63837, 62214, 117871, 70618, 52198, 71079, 36721, 43, 68142, 102563, 38282, 30698, 3687, 63400, 19506, 86312, 58839, 85891, 24238, 73, 1499, 47315, 7349, 107478, 118062, 102911, 75606, 31122, 87403, 17513, 34840, 69834, 22736, 12515, 104034, 118257, 77892, 28513, 85789, 37739, 11674, 22000, 66199, 107433, 120343, 64231, 97450, 4213, 114993, 9819, 2845, 84878, 8089, 26327, 67145, 44151, 11899, 81228, 114687, 65419, 6916, 103494, 130217, 94805, 72228, 128608, 88751, 28958, 47253, 79866, 85019, 18886, 42779, 100392, 34431, 42967, 34572, 72941, 68886, 81366, 97042, 61096, 14632, 77789, 98351, 79566, 25779, 4966, 54017, 42457, 6983, 39016, 124231, 33919, 62769, 12199, 42915, 78887, 32987, 16968, 11168, 115352, 122482, 52899, 123383, 34035, 61897, 97884, 129294, 126435, 20093, 100788, 40896, 4882, 82520, 130076, 12387, 38366, 107002, 77323, 34822, 123724, 80821, 100369, 3578, 130876, 70841, 58154, 77715, 20190, 54384, 72279, 87087, 71268, 66091, 106858, 36215, 40440, 63742, 79137, 100325, 78320, 112103, 129142, 98181, 29248, 58421, 103221, 15614, 107824, 117799, 9678, 24275, 334, 2002, 9836, 29414, 74405, 8776, 31558, 107582, 73518, 34038, 91700, 65801, 61062, 87886, 5508, 40164, 71905, 13477, 126478, 4953, 123198, 56413, 123525, 11944, 89819, 16454, 93200, 112329, 80363, 103745, 129048, 109745, 65414, 84518, 57187, 95700, 82145, 2279, 80481, 113643, 61886, 9717, 9926, 66806, 113189, 8674, 86616, 83844, 77652, 74055, 57097, 130866, 10227, 32487, 62536, 34160, 40844, 121876, 37267, 45707, 122169, 86865, 30288, 2790, 119198, 110904, 13021, 130186, 122905, 55197, 46821, 127202, 34616, 44788, 61685, 14014, 40043, 84463, 21326, 67745, 3834, 73579, 20988, 78648, 91704, 32396, 77351, 8231, 28409, 106790, 107176, 84235, 117824, 65630, 17887, 87740, 24380, 118672, 46275, 94418, 47733, 49523, 121657, 98666, 5186, 97147, 126378, 28970, 93310, 88958, 124879, 106369, 55675, 29594, 107726, 72499, 12341, 122965, 58506, 24340, 97226, 56581, 53814, 104211, 63529, 14961, 57387, 110970, 99338, 7096, 68860, 114803, 114205, 7537, 58822, 28621, 82309, 19219, 121291, 37632, 46471, 99991, 45890, 3950, 42110, 18011, 84328, 42731, 19986, 52553, 49114, 26239, 59561, 16696, 124710, 114026, 67100, 17297, 37534, 98407, 69550, 61493, 128880, 89397, 68921, 91806, 92403, 98898, 76713, 82244, 1603, 32521, 112302, 106305, 77071, 40879, 31149, 42039, 50609, 18984, 48119, 37489, 113790, 73392, 19516, 123720, 15455, 123095, 85825, 455, 32416, 93389, 116177, 35730, 17415, 81119, 65008, 80899, 19240, 17217, 25430, 58773, 22519, 72718, 25371, 7557, 106654, 56204, 87726, 32182, 45969, 130227, 109067, 106708, 76510, 78831, 110892, 81084, 49353, 10788, 57536, 130843, 39320, 25587, 89626, 69716, 54954, 55611, 6764, 24743, 116430, 65762, 60724, 9103, 83921, 21717, 90613, 7530, 11608, 102988, 11562, 108383, 49392, 80466, 31863, 101755, 44899, 71300, 103969, 76573, 128845, 50712, 31680, 27028, 109806, 104225, 33843, 34054, 42816, 12304, 73939, 113555, 92747, 52605, 16874, 19129, 123576, 71719, 3686, 89849, 50852, 55097, 123593, 55739, 110519, 66255, 117603, 69998, 17012, 64183, 60867, 126963, 128721, 124283, 38250, 70459, 87562, 31647, 55234, 54318, 49585, 115494, 66382, 22478, 6154, 98139, 85537, 69276, 117141, 88269, 30612, 17978, 78827, 410, 86323, 110929, 87501, 121328, 90871, 2484, 12409, 55505, 73402, 78021, 27199, 113941, 87782, 94743, 1620, 51893, 60528, 117844, 17894, 38981, 59396, 91233, 1648, 110786, 29313, 34495, 78159, 3470, 90280, 121652, 69780, 109751, 83471, 44714, 40218, 116607, 17243, 96086, 72155, 27928, 941, 128796, 36991, 34222, 40284, 41009, 66357, 33195, 18917, 73729, 26566, 14646, 10527, 13395, 49127, 49147, 99250, 77483, 58062, 78129, 16585, 117231, 117767, 112600, 33542, 79437, 99207, 22339, 41142, 98139, 127745, 79829, 125766, 45183, 81016, 31759, 129524, 88976, 26133, 123337, 93129, 26045, 28473, 46015, 21701, 16045, 74454, 53071, 117340, 124392, 15098, 115328, 82721, 25205, 43436, 83526, 114112, 102595, 72443, 39171, 123698, 92876, 1107, 32081, 104491, 77431, 54546, 123134, 45525, 1597, 72794, 94295, 115139, 71695, 112680, 39337, 77088, 73335, 90533, 50436, 806, 126973, 76476, 115778, 83670, 39115, 49388, 48967, 106469, 60051, 100702, 73865, 42741, 108208, 59961, 83410, 16644, 42635, 87349, 63812, 114217, 42560, 59246, 128669, 110460, 38272, 111226, 65724, 43094, 37560, 66237, 19300, 24250, 62579, 14075, 15679, 122642, 1276, 64814, 118308, 50973, 87110, 2201, 1436, 48167, 115728, 38172, 23970, 102523, 111172, 19402, 3498, 117782, 58784, 23736, 33252, 35997, 8343, 123415, 99009, 61583, 32377, 57477, 118965, 33214, 65233, 30879, 79934, 86779, 58125, 7642, 90661, 115984, 115300, 59027, 58372, 75506, 30708, 84323, 21767, 107831, 20266, 56248, 92918, 81093, 4710, 58785, 25458, 42187, 57309, 122600, 15742, 25589, 59585, 76133, 34625, 99547, 32416, 105617, 115721, 40377, 4873, 46681, 110227, 73573, 3444, 99636, 56201, 8061, 105315, 106359, 98379, 70111, 122564, 113639, 90610, 9566, 73369, 49039, 77969, 79793, 122330, 87252, 119485, 103598, 130201, 90054, 25935, 128184, 18279, 123832, 127847, 93814, 71926, 77330, 10932, 85957, 61951, 23141, 36851, 70127, 11109, 33727, 128949, 56604, 75418, 79680, 18276, 20232, 41026, 64493, 49799, 30966, 2325, 963, 92228, 84196, 2313, 23055, 9510, 119295, 102575, 8956, 56609, 10329, 7388, 114797, 102866, 50136, 4236, 61452, 10506, 40561, 18692, 79523, 104333, 33174, 20534, 76970, 29718, 79596, 53608, 98336, 79518, 102465, 13334, 114590, 42973, 31421, 98583, 17064, 83216, 37206, 128511, 115526, 39933, 123529, 125637, 31955, 123700, 122182, 126372, 123924, 86678, 39211, 80197, 85131, 26, 126453, 59677, 69389, 17614, 3635, 102420, 66962, 60956, 39227, 71015, 28747, 114511, 22626, 64462, 38906, 1876, 72550, 95968, 49533, 20164, 26671, 127670, 83626, 25121, 61879, 127439, 59490, 80991, 2629, 91443, 44512, 38310, 99552, 123610, 124242, 6742, 113155, 24141, 72106, 36427, 41868, 83853, 4533, 90209, 17402, 78900, 11371, 94778, 117975, 30426, 110217, 6206, 14451, 18618, 120157, 103907, 19154, 27028, 49888, 39470, 77287, 22996, 104201, 32888, 7425, 103154, 19039, 22901, 54148, 25116, 7632, 65650, 111324, 84243, 46017, 49373, 119727, 67922, 75366, 86026, 30289, 114036, 110418, 73524, 34428, 107734, 111697, 84417, 9792, 34171, 85365, 107465, 95288, 51248, 39022, 44248, 65790, 111344, 27935, 92915, 108512, 25993, 83821, 94681, 48851, 97406, 31321, 105098, 53671, 97839, 65616, 12044, 23676, 30263, 31937, 101996, 80244, 90901, 17136, 36099, 46505, 23053, 95753, 5370, 98657, 34128, 38520, 117519, 126848, 90202, 4215, 113560, 14397, 54939, 40936, 86984, 111384, 10329, 105828, 11056, 80907, 113108, 34963, 90504, 14335, 12458, 25533, 38063, 60545, 99197, 46241, 111344, 7861, 57298, 81541, 77191, 77194, 35388, 51598, 20323, 72495, 72889, 35665, 113708, 14789, 116571, 66729, 23430, 94037, 96042, 26826, 78999, 83203, 67400, 123286, 64967, 13699, 57430, 17711, 25798, 61132, 43542, 4301, 21202, 31500, 127825, 113872, 110906, 99547, 62459, 48664, 29213, 76466, 52628, 51348, 123255, 71070, 60880, 10009, 33373, 116528, 96121, 81012, 130183, 86711, 54676, 33217, 122383, 128433, 56514, 103934, 13688, 82813, 7913, 78554, 83953, 120917, 21779, 72403, 124889, 51068, 66453, 21631, 12165, 80051, 113779, 83753, 42049, 125168, 107523, 35999, 1429, 98898, 7119, 35913, 19656, 130894, 47040, 78717, 106665, 36142, 57719, 24338, 16780, 41404, 118270, 51762, 45459, 14394, 108959, 38516, 105774, 27028, 73236, 114986, 83940, 54232, 38624, 6646, 33106, 99557, 59387, 102051, 91764, 23650, 80564, 57393, 29475, 6386, 25811, 5425, 42974, 33957, 3581, 81235, 116684, 29873, 18268, 88637, 127745, 102497, 31102, 33181, 8448, 70476, 52349, 101505, 81792, 130762, 93792, 59365, 129394, 28324, 89025, 88717, 92739, 66826, 36527, 54293, 82270, 41417, 112597, 39238, 6644, 121020, 124379, 90538, 68351, 56195, 48908, 80481, 111491, 117363, 12600, 16950, 18198, 41165, 48091, 37612, 89763, 77873, 112766, 60382, 102762, 57172, 83293, 61894, 72266, 73712, 112201, 71644, 3394, 53244, 45007, 99874, 123189, 129565, 20634, 37118, 86509, 43355, 68885, 38408};

        int[] g;
        g = new Random().ints(0, 1 << 24).limit(10000).toArray();

        System.out.println(Arrays.toString(g));

        int[] binDecNeg = {-1,-5,-22};
        System.out.println(Integer.toBinaryString(binDecNeg[2]));
        sort(g, 0,0, g.length);

        System.out.print(Arrays.toString(g));
    }
    public LSDRadixSort() {}

    /* ---------------- Insertion sort section ---------------- */
    //Jan 2021 update: 113  March 2022 update: 124
    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 113;
    //Jan 2021 update: 26  March 2022 update: 20
    private static final int MAX_INSERTION_SORT_SIZE = 26;

    //removed. new parallel sorting section below
    private static final int MIN_PARALLEL_SORT_SIZE = 4 << 10;

    /* ----------------- Merging sort section ----------------- */

    //New. 4 << 10
    private static final int MIN_MERGING_SORT_SIZE = 512;

    /**
     * old: Min size of the first run to continue with scanning
     * new: Min size of run to continue scanning.
     */
    private static final int MIN_FIRST_RUN_SIZE = 16;
    private static final int MIN_RUN_SIZE = 128;

    /**
     * old: Min factor for the first runs to continue scanning.
     * Min number of runs for parallel merging.
     */
    private static final int MIN_FIRST_RUNS_FACTOR = 7;
    private static final int MIN_PARALLEL_RUN_MERGING_COUNT = 4;

    /**
     * Old: Max capacity of the index array for tracking runs.
     * New: Min array size to invoke parallel merging of parts.
     */
    private static final int MAX_RUN_CAPACITY = 5 << 10;
    private static final int MIN_PARALLEL_PART_MERGING_SIZE = 4 << 10;

    /**
     * Old: Min number of runs, required by parallel merging.
     */
    private static final int MIN_RUN_COUNT = 4;

    /* ------------------ Radix sort section ------------------ */
    /**
     * Moved to section: Min array size to use parallel merging of parts.
     * New: Min array size to use Radix sort.
     */
    private static final int MIN_PARALLEL_MERGE_PARTS_SIZE = 4 << 10;
    private static final int MIN_RADIX_SORT_SIZE = 768;

    /* ------------------ Counting sort section --------------- */
    /**
     * Min size of a byte array to use counting sort.
     */
    private static final int MIN_BYTE_COUNTING_SORT_SIZE = 64;

    /**
     * Min size of a short or char array to use counting sort.
     */
    private static final int MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE = 1750;


    /**
     * Threshold of mixed insertion sort is increased by this value.
     */
    private static final int DEPTH = 3 << 1;

    /* -------------------- Common section -------------------- */

    /**
     * Old Min depth to invoke Radix sort.
     * Max recursive depth before switching to heap sort.
     */
    private static final int MIN_RADIX_SORT_DEPTH = DEPTH << 2;
    private static final int MAX_RECURSION_DEPTH = 64 * DEPTH;

    /**
     * Max length of additional buffer,
     * limited by max_heap / 64 or 256m elements (2gb max).
     * Max length of additional buffer, limited by
     *      max_heap / 64 or 256mb elements (2gb max).
     */
    private static final int MAX_BUFFER_LENGTH =
            (int) Math.min(Runtime.getRuntime().maxMemory() >> 6, 256L << 20);

    /**
     * Sorts the specified range of the array using parallel merge
     * sort and/or Dual-Pivot Quicksort.
     *
     * To balance the faster splitting and parallelism of merge sort
     * with the faster element partitioning of Quicksort, ranges are
     * subdivided in tiers such that, if there is enough parallelism,
     * the four-way parallel merge is started, still ensuring enough
     * parallelism to process the partitions.
     *
     * @param a the array to be sorted
     * @param parallelism the parallelism level
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    static void sort(int[] a, int parallelism, int low, int high) {
        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {
            new Sorter(a, parallelism, low, high - low, 0).invoke();
        } else {
            sort(null, a, 0, low, high);
        }
    }

    /**
     * Sorts the specified range of the array using Dual-Pivot Quicksort.
     *
     * @param sorter parallel context
     * @param a the array to be sorted
     * @param bits the combination of recursion depth and bit flag, where
     *        the right bit "0" indicates that range is the leftmost part
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    static void sort(Sorter sorter, int[] a, int bits, int low, int high) {
        while (true) {
            int end = high - 1, size = high - low;

            /*
             * Run mixed insertion sort on small non-leftmost parts.
             * New: Run adaptive mixed insertion sort on small non-leftmost parts.
             */
            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {
                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);
                //new: mixedInsertionSort(a, low, high);
                return;
            }

            /*
             * Invoke insertion sort on small leftmost part.
             */
            if (size < MAX_INSERTION_SORT_SIZE) {
                insertionSort(a, low, high, (bits & 1) == 0);
                //new: insertionSort(a, low, high);
                return;
            }

            /*
             * Check if the whole array or large non-leftmost
             * parts are nearly sorted and then merge runs.
             */
            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)
                    //new: if (size > MIN_MERGING_SORT_SIZE * bits
                    && tryMergingSort(sorter, a, low, size)) {
                return;
            }

            /*
             * Old: Switch to heap sort, if execution time is quadratic.
             * Removed from this section
             */
            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {
                heapSort(a, low, high);
                return;
            }

            /*
             * Use an inexpensive approximation of the golden ratio
             * to select five sample elements and determine pivots.
             */
            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;
            System.out.println("\n size >> 2 " + (size>>2) + " size >> 3" + (size >> 3) + "size >> 8" + (size >> 8) + 1 + " = "  + step);


            /*
             * Five elements around (and including) the central element
             * will be used for pivot selection as described below. The
             * unequal choice of spacing these elements was empirically
             * determined to work well on a wide variety of inputs.
             */
            int e1 = low + step;
            System.out.print("\ne1 = low + step  " + e1);
            int e5 = end - step;
            System.out.print("e5 = end - step  " + e5);
            int e3 = (e1 + e5) >>> 1;
            System.out.print("e3 = e1 + e5 >>> 1  " + e3);
            int e2 = (e1 + e3) >>> 1;
            System.out.print("e2 = e1 + e3 >>> 1  " + e2+ "\n");
            int e4 = (e3 + e5) >>> 1;
            int a3 = a[e3];

            //new:  a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5];
            boolean isRandom =
                    a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];
            System.out.println("\n boolean isRandom "+ isRandom+ " if any are true: a["+e1+"] > a["+e2+"] || a["+e2+"] a["+e3+"] || a["+e3+"] > a["+e4+"] || a["+e4+"] > a["+e5+"]\n");

            System.out.print("\n" + a[e1] + ", " + a[e2] + ", " + a[e3] + ", " + a[e4] + ", " + a[e5] + ", " );

            /*
             * Sort these elements in place by the combination
             * of 4-element sorting network and insertion sort.
             *
             *    1  ------------o-----o------------
             *                   |     |
             *    2  ------o-----|-----o-----o------
             *             |     |           |
             *    4  ------|-----o-----o-----o------
             *             |           |
             *    5  ------o-----------o------------
             */
            System.out.println("\n Sorting network a[e1], a[e2], a[e3], a[e4]: a["+e1+"] a["+e2+"] a["+e4+"] a["+e5+"]");
            if (a[e2] > a[e5]) { int t = a[e2]; a[e2] = a[e5]; a[e5] = t; System.out.println(" a[e2] > a[e5]: t = " + a[e2] + " a[e2] = "+ a[e5] + " a[e5] = t");}

            if (a[e1] > a[e4]) { int t = a[e1]; a[e1] = a[e4]; a[e4] = t;System.out.println(" a[e1] > a[e4]: t = " + a[e1] + " a[e1] = "+ a[e4] + " a[e4] = t");}

            if (a[e1] > a[e2]) { int t = a[e1]; a[e1] = a[e2]; a[e2] = t; System.out.println(" a[e2] > a[e5]: t = " + a[e1] + " a[e1] = "+ a[e2] + " a[e2] = t");}

            if (a[e4] > a[e5]) { int t = a[e4]; a[e4] = a[e5]; a[e5] = t; System.out.println(" a[e4] > a[e5]: t = " + a[e4] + " a[e4] = "+ a[e5] + " a[e5] = t");}

            if (a[e2] > a[e4]) { int t = a[e2]; a[e2] = a[e4]; a[e4] = t;System.out.println(" a[e2] > a[e4]: t = " + a[e2] + " a[e4] = "+ a[e5] + " a[e5] = t\n");}


            /*
             * Insert the third element.
             */
            System.out.println(" Checking where to insert a3 ");
            if (a3 < a[e2]) {
                System.out.println(" and a[e3] = a[e2]; a[e2]=a[e1]; a[e1] = a3; a[e2]=a[e1] and a[e3] ");
                if (a3 < a[e1]) {
                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;
                } else {
                    System.out.println(" a[e3] = a[e2] and a[e2] = a3 ");
                    a[e3] = a[e2]; a[e2] = a3;
                }
            } else if (a3 > a[e4]) {
                System.out.println(" a[e3] = a[e4];  a[e4] = a[e5];  a[e5] = a3 ");
                if (a3 > a[e5]) {
                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;
                } else {
                    System.out.println(" a[e3] = a[e4];  a[e4] = a[e5];  a[e5] = a3 ");
                    a[e3] = a[e4]; a[e4] = a3;
                }
            }

            /*
             * Try Radix sort on large fully random data,
             * taking into account parallel context.
             */
            System.out.println(" \nsize " + size + " > MIN_RADIX_SORT_SIZE " + MIN_RADIX_SORT_SIZE + " \n" +
                    a[e1] + " < " + a[e2] +" && "+ a[e2] + " < " + a[e4] + " && " + a[e4] + " < " + a[e5] + "\n" +
                    "and bits " + bits + " > MIN_RADIX_SORT_DEPTH " + MIN_RADIX_SORT_DEPTH);
            if (size > MIN_RADIX_SORT_SIZE
                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5] && isRandom
                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)
                    && tryRadixSort(sorter, a, low, high)) {
                return;
            }
//           new: isRandom &= a[e1] < a[e2] && a[e2] < a[e3] & a[e3] < a[e4] && a[e4] < a[e5];
//
//            if (size > MIN_RADIX_SORT_SIZE && isRandom
            // Pointers
            int lower = low; // The index of the last element of the left part
            int upper = end; // The index of the first element of the right part

            /*
             * Partitioning with two pivots on array of random elements.
             */
            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {

                /*
                 * Use the first and fifth of the five sorted elements as
                 * the pivots. These values are inexpensive approximation
                 * of tertiles. Note, that pivot1 < pivot2.
                 */
                int pivot1 = a[e1];
                int pivot2 = a[e5];

                /*
                 * The first and the last elements to be sorted are moved
                 * to the locations formerly occupied by the pivots. When
                 * partitioning is completed, the pivots are swapped back
                 * into their final positions, and excluded from the next
                 * subsequent sorting.
                 */
                a[e1] = a[lower];
                a[e5] = a[upper];

                /*
                 * Skip elements, which are less or greater than the pivots.
                 */
                while (a[++lower] < pivot1);
                while (a[--upper] > pivot2);

                /*
                 * Backward 3-interval partitioning
                 *
                 *     left part                    central part          right part
                 * +------------------------------------------------------------------+
                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |
                 * +------------------------------------------------------------------+
                 *               ^         ^                            ^
                 *               |         |                            |
                 *             lower       k                          upper
                 *
                 * Pointer k is the last index of ?-part
                 * Pointer lower is the last index of left part
                 * Pointer upper is the first index of right part
                 *
                 * Invariants:
                 *
                 *     all in (low, lower]  <  pivot1
                 *     all in (k, upper)   in [pivot1, pivot2]
                 *     all in [upper, end)  >  pivot2
                 */
                for (int unused = --lower, k = ++upper; --k > lower; ) {
                    int ak = a[k];

                    if (ak < pivot1) { // Move a[k] to the left side
                        while (a[++lower] < pivot1) {
                            if (lower == k) {
                                break;
                            }
                        }
                        if (a[lower] > pivot2) {
                            a[k] = a[--upper];
                            a[upper] = a[lower];
                        } else {
                            a[k] = a[lower];
                        }
                        a[lower] = ak;
                    } else if (ak > pivot2) { // Move a[k] to the right side
                        a[k] = a[--upper];
                        a[upper] = ak;
                    }
                }

                /*
                 * Swap the pivots into their final positions.
                 */
                a[low] = a[lower]; a[lower] = pivot1;
                a[end] = a[upper]; a[upper] = pivot2;

                /*
                 * Sort non-left parts recursively (possibly in parallel),
                 * excluding known pivots.
                 */
                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {
                    sorter.forkSorter(bits | 1, lower + 1, upper);
                    sorter.forkSorter(bits | 1, upper + 1, high);
                } else {
                    sort(sorter, a, bits | 1, lower + 1, upper);
                    sort(sorter, a, bits | 1, upper + 1, high);
                }

            } else { // Partitioning with one pivot

                /*
                 * Use the third of the five sorted elements as the pivot.
                 * This value is inexpensive approximation of the median.
                 */
                int pivot = a[e3];

                /*
                 * The first element to be sorted is moved to the
                 * location formerly occupied by the pivot. After
                 * completion of partitioning the pivot is swapped
                 * back into its final position, and excluded from
                 * the next subsequent sorting.
                 */
                a[e3] = a[lower];

                /*
                 * Dutch National Flag partitioning
                 *
                 *    left part                central part    right part
                 * +------------------------------------------------------+
                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |
                 * +------------------------------------------------------+
                 *              ^           ^                ^
                 *              |           |                |
                 *            lower         k              upper
                 *
                 * Pointer k is the last index of ?-part
                 * Pointer lower is the last index of left part
                 * Pointer upper is the first index of right part
                 *
                 * Invariants:
                 *
                 *     all in (low, lower]  <  pivot
                 *     all in (k, upper)   ==  pivot
                 *     all in [upper, end]  >  pivot
                 */
                for (int k = ++upper; --k > lower; ) {
                    int ak = a[k];

                    if (ak != pivot) {
                        a[k] = pivot;

                        if (ak < pivot) { // Move a[k] to the left side
                            while (a[++lower] < pivot);

                            if (a[lower] > pivot) {
                                a[--upper] = a[lower];
                            }
                            a[lower] = ak;
                        } else { // ak > pivot - Move a[k] to the right side
                            a[--upper] = ak;
                        }
                    }
                }

                /*
                 * Swap the pivot into its final position.
                 */
                a[low] = a[lower]; a[lower] = pivot;

                /*
                 * Sort the right part (possibly in parallel), excluding
                 * known pivot. All elements from the central part are
                 * equal and therefore already sorted.
                 */
                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {
                    sorter.forkSorter(bits | 1, upper, high);
                } else {
                    sort(sorter, a, bits | 1, upper, high);
                }
            }
            high = lower; // Iterate along the left part
        }
    }

    /**
     * Sorts the specified range of the array using mixed insertion sort.
     *
     * Mixed insertion sort is combination of pin insertion sort,
     * simple insertion sort and pair insertion sort.
     *
     * In the context of Dual-Pivot Quicksort, the pivot element
     * from the left part plays the role of sentinel, because it
     * is less than any elements from the given part. Therefore,
     * expensive check of the left range can be skipped on each
     * iteration unless it is the leftmost call.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param end the index of the last element for simple insertion sort
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void mixedInsertionSort(int[] a, int low, int end, int high) {

        /*
         * Start with pin insertion sort.
         */
        for (int i, p = high; ++low < end && low < p; ) {
            int ai = a[i = low];

            /*
             * Find pin element, smaller than the given element.
             */
            while (ai < a[--p]);

            /*
             * Swap these elements.
             */
            ai = a[p]; a[p] = a[i];

            /*
             * Insert element into sorted part.
             */
            while (ai < a[--i]) {
                a[i + 1] = a[i];
            }
            a[i + 1] = ai;
        }

        /*
         * Continue with simple insertion sort.
         */
        for (int i; low < end; ++low) {
            int ai = a[i = low];

            /*
             * Insert element into sorted part.
             */
            while (ai < a[--i]) {
                a[i + 1] = a[i];
            }
            a[i + 1] = ai;
        }

        /*
         * Finish with pair insertion sort.
         */
        for (int i; low < high; ++low) {
            int a1 = a[i = low], a2 = a[++low];

            /*
             * Insert two elements per iteration: at first, insert the
             * larger element and then insert the smaller element, but
             * from the position where the larger element was inserted.
             */
            if (a1 > a2) {

                while (a1 < a[--i]) {
                    a[i + 2] = a[i];
                }
                a[++i + 1] = a1;

                while (a2 < a[--i]) {
                    a[i + 1] = a[i];
                }
                a[i + 1] = a2;

            } else if (a1 < a[i - 1]) {

                while (a2 < a[--i]) {
                    a[i + 2] = a[i];
                }
                a[++i + 1] = a2;

                while (a1 < a[--i]) {
                    a[i + 1] = a[i];
                }
                a[i + 1] = a1;
            }
        }
    }

    /**
     * Sorts the specified range of the array using insertion sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     * @param leftmost indicates that the range is the leftmost part
     */
    private static void insertionSort(int[] a, int low, int high, boolean leftmost) {
        if (leftmost) {
            for (int i, k = low; ++k < high; ) {
                int ai = a[i = k];

                if (ai < a[i - 1]) {
                    while (--i >= low && ai < a[i]) {
                        a[i + 1] = a[i];
                    }
                    a[i + 1] = ai;
                }
            }
        } else {
            for (int i; ++low < high; ) {
                int ai = a[i = low];

                while (ai < a[--i]) {
                    a[i + 1] = a[i];
                }
                a[i + 1] = ai;
            }
        }
    }

    /**
     * Tries to sort the specified range of the array
     * using LSD (Least Significant Digit) Radix sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     * @return {@code true} if the array is finally sorted, otherwise {@code false}
     */
    static boolean tryRadixSort(Sorter sorter, int[] a, int low, int high) {
        int[] b; int offset = low, size = high - low;
        /*
         * Allocate additional buffer.
         */
        if (sorter != null && (b = (int[]) sorter.b) != null) {

            offset = sorter.offset;
        } else {
            if ((b = (int[]) tryAllocate(a, size)) == null) {
                return false;
            }
        }

        int start = low - offset;
        int last = high - offset;
        System.out.println("high " + high);
        /*
         * Count the number of all digits.
         */

        int[] count1 = new int[1024];
        int[] count2 = new int[2048];
        int[] count3 = new int[2048];

        for (int i = low; i < high; ++i) {

            count1[ a[i] & 0x3FF]--;
            count2[(a[i] >>> 10) & 0x7FF]--;
            count3[(a[i] >>> 21) ^ 0x400]--; // Reverse the sign bit

        }
        /*
         * Detect digits to be processed.
         */
        boolean processDigit1 = processDigit(count1, 1023, -size, high);
        boolean processDigit2 = processDigit(count2, 2047, -size, high);
        boolean processDigit3 = processDigit(count3, 2047, -size, high);
        /*
         * Process the 1-st digit.
         */
        if (processDigit1) {
            for (int i = low; i < high; ++i) {
                b[count1[a[i] & 0x3FF]++ - offset] = a[i];
            }
        }

        /*
         * Process the 2-nd digit.
         */
        if (processDigit2) {
            if (processDigit1) {
                for (int i = start; i < last; ++i) {
                    a[count2[(b[i] >>> 10) & 0x7FF]++] = b[i];
                }
            } else {
                for (int i = low; i < high; ++i) {
                    b[count2[(a[i] >>> 10) & 0x7FF]++ - offset] = a[i];
                }
            }
        }

        /*
         * Process the 3-rd digit.
         */
        if (processDigit3) {
            if (processDigit1 ^ processDigit2) {

                for (int i = start; i < last; ++i) {
                    a[count3[(b[i] >>> 21) ^ 0x400]++] = b[i];
                }
            } else {
                for (int i = low; i < high; ++i) {
                    System.out.println(" i = " + i + "\n a[i] = " + a[i] + "\n (a[i] >>> 21) ^ 0x400 = " + ((a[i] >>> 21) & 0x400) +
                            "\ncount3[(a[i] >>> 21) & 0x400] " + count3[(a[i] >>> 21) ^ 0x400]
                            + "\n"+Integer.toBinaryString(a[i]) +  "&\n" + Integer.toBinaryString(0x400) + "\n" + Integer.toBinaryString((a[i] >>> 21) ^ 0x400));
                    b[count3[(a[i] >>> 21) ^ 0x400]++ - offset] = a[i];
                }
            }
        }

        /*
         * Copy the buffer to original array, if we process ood number of digits.
         */
        if (processDigit1 ^ processDigit2 ^ processDigit3) {
            System.arraycopy(b, low - offset, a, low, size);
        }
        return true;
    }

    /**
     * Checks the count array and then creates histogram.
     *
     * @param count the count array
     * @param last the last index of count array
     * @param total 0
     * @param high the index of the last element, exclusive
     * @return {@code true} if the digit must be processed, otherwise {@code false}
     */

    private static int coun= 0;
    private static boolean processDigit(int[] count, int last, int total, int high) {
        /*
         * Check if we can skip given digit.
         */
        for (int c : count) {
            if (c == total) {
                return false;
            }
            if (c < 0) {
                break;
            }
        }

        /*
         * Compute the histogram.
         */
        count[last] += high;
        for (int i = last; i > 0; --i) {
            count[i - 1] += count[i];
        }
        return true;
    }

    /**
     * Sorts the specified range of the array using heap sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void heapSort(int[] a, int low, int high) {
        for (int k = (low + high) >>> 1; k > low; ) {
            pushDown(a, --k, a[k], low, high);
        }
        while (--high > low) {
            int max = a[low];
            pushDown(a, low, a[high], low, high);
            a[high] = max;
        }
    }

    /**
     * Pushes specified element down during heap sort.
     *
     * @param a the given array
     * @param p the start index
     * @param value the given element
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void pushDown(int[] a, int p, int value, int low, int high) {
        for (int k ;; a[p] = a[p = k]) {
            k = (p << 1) - low + 2; // Index of the right child

            if (k > high) {
                break;
            }
            if (k == high || a[k] < a[k - 1]) {
                --k;
            }
            if (a[k] <= value) {
                break;
            }
        }
        a[p] = value;
    }

    /**
     * Tries to sort the specified range of the array using merging sort.
     *
     * @param sorter parallel context
     * @param a the array to be sorted
     * @param low the index of the first element to be sorted
     * @param size the array size
     * @return {@code true} if the array is finally sorted, otherwise {@code false}
     */
    private static boolean tryMergingSort(Sorter sorter, int[] a, int low, int size) {

        /*
         * The run array is constructed only if initial runs are
         * long enough to continue, run[i] then holds start index
         * of the i-th sequence of elements in non-descending order.
         */
        int[] run = null;
        int high = low + size;
        int count = 1, last = low;

        /*
         * Identify all possible runs.
         */
        for (int k = low + 1; k < high; ) {

            /*
             * Find the end index of the current run.
             */
            if (a[k - 1] < a[k]) {

                // Identify ascending sequence
                while (++k < high && a[k - 1] <= a[k]);

            } else if (a[k - 1] > a[k]) {

                // Identify descending sequence
                while (++k < high && a[k - 1] >= a[k]);

                // Reverse into ascending order
                for (int i = last - 1, j = k; ++i < --j && a[i] > a[j]; ) {
                    int ai = a[i]; a[i] = a[j]; a[j] = ai;
                }
            } else { // Identify constant sequence
                for (int ak = a[k]; ++k < high && ak == a[k]; );

                if (k < high) {
                    continue;
                }
            }

            /*
             * Check special cases.
             */
            if (run == null) {
                if (k == high) {
                    /*
                     * The array is monotonous sequence,
                     * and therefore already sorted.
                     */
                    return true;
                }

                if (k - low < MIN_FIRST_RUN_SIZE) {
                    /*
                     * The first run is too small
                     * to proceed with scanning.
                     */
                    return false;
                }

                // Initial min 127, max 1023, extended to 5120
                run = new int[((size >> 10) | 0x7F) & 0x3FF];
                run[0] = low;

            } else if (a[last - 1] > a[last]) { // Start new run

                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {
                    /*
                     * The first runs are not long
                     * enough to continue scanning.
                     */
                    return false;
                }

                if (++count == MAX_RUN_CAPACITY) {
                    /*
                     * Array is not highly structured.
                     */
                    return false;
                }

                if (count == run.length) {
                    /*
                     * Increase capacity of index array.
                     */
                    run = Arrays.copyOf(run, count << 1);
                }
            }
            run[count] = (last = k);

            if (++k == high) {
                /*
                 * This is single-element run at the end.
                 */
                --k;
            }
        }

        /*
         * Merge runs of highly structured array.
         */
        if (count > 1) {
            int[] b; int offset = low;

            if (sorter != null && (b = (int[]) sorter.b) != null) {
                offset = sorter.offset;
            } else {
                if ((b = (int[]) tryAllocate(a, size)) == null) {
                    return false;
                }
            }
            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);
        }
        return true;
    }

    /**
     * Merges the specified runs.
     *
     * @param a the source array
     * @param b the temporary buffer used in merging
     * @param offset the start index in the source, inclusive
     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)
     * @param parallel indicates whether merging is performed in parallel
     * @param run the start indexes of the runs, inclusive
     * @param lo the start index of the first run, inclusive
     * @param hi the start index of the last run, inclusive
     * @return the destination where runs are merged
     */
    private static int[] mergeRuns(int[] a, int[] b, int offset,
                                   int aim, boolean parallel, int[] run, int lo, int hi) {

        if (hi - lo == 1) {
            if (aim >= 0) {
                return a;
            }
            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);
            return b;
        }

        /*
         * Split into approximately equal parts.
         */
        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;
        while (run[++mi + 1] <= rmi);

        /*
         * Merge the left and right parts.
         */
        int[] a1, a2;

        if (parallel && hi - lo > MIN_RUN_COUNT) {
            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();
            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);
            a2 = (int[]) merger.getDestination();
        } else {
            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);
            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);
        }

        int[] dst = a1 == a ? b : a;

        int k   = a1 == a ? run[lo] - offset : run[lo];
        int lo1 = a1 == b ? run[lo] - offset : run[lo];
        int hi1 = a1 == b ? run[mi] - offset : run[mi];
        int lo2 = a2 == b ? run[mi] - offset : run[mi];
        int hi2 = a2 == b ? run[hi] - offset : run[hi];

        if (parallel) {
            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();
        } else {
            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);
        }
        return dst;
    }

    /**
     * Merges the sorted parts.
     *
     * @param merger parallel context
     * @param dst the destination where parts are merged
     * @param k the start index of the destination, inclusive
     * @param a1 the first part
     * @param lo1 the start index of the first part, inclusive
     * @param hi1 the end index of the first part, exclusive
     * @param a2 the second part
     * @param lo2 the start index of the second part, inclusive
     * @param hi2 the end index of the second part, exclusive
     */
    private static void mergeParts(Merger merger, int[] dst, int k,
                                   int[] a1, int lo1, int hi1, int[] a2, int lo2, int hi2) {

        if (merger != null && a1 == a2) {

            while (true) {

                /*
                 * The first part must be larger.
                 */
                if (hi1 - lo1 < hi2 - lo2) {
                    int lo = lo1; lo1 = lo2; lo2 = lo;
                    int hi = hi1; hi1 = hi2; hi2 = hi;
                }

                /*
                 * Small parts will be merged sequentially.
                 */
                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {
                    break;
                }

                /*
                 * Find the median of the larger part.
                 */
                int mi1 = (lo1 + hi1) >>> 1;
                int key = a1[mi1];
                int mi2 = hi2;

                /*
                 * Partition the smaller part.
                 */
                for (int loo = lo2; loo < mi2; ) {
                    int t = (loo + mi2) >>> 1;

                    if (key > a2[t]) {
                        loo = t + 1;
                    } else {
                        mi2 = t;
                    }
                }

                /*
                 * Reserve space for the left sub-parts.
                 */
                int d = mi2 - lo2 + mi1 - lo1;

                /*
                 * Merge the right sub-parts in parallel.
                 */
                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);

                /*
                 * Process the sub-left parts.
                 */
                hi1 = mi1;
                hi2 = mi2;
            }
        }

        /*
         * Merge small parts sequentially.
         */
        while (lo1 < hi1 && lo2 < hi2) {
            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];
        }
        if (dst != a1 || k < lo1) {
            while (lo1 < hi1) {
                dst[k++] = a1[lo1++];
            }
        }
        if (dst != a2 || k < lo2) {
            while (lo2 < hi2) {
                dst[k++] = a2[lo2++];
            }
        }
    }

// #[long]

    /**
     * Sorts the specified range of the array using parallel merge
     * sort and/or Dual-Pivot Quicksort.
     *
     * To balance the faster splitting and parallelism of merge sort
     * with the faster element partitioning of Quicksort, ranges are
     * subdivided in tiers such that, if there is enough parallelism,
     * the four-way parallel merge is started, still ensuring enough
     * parallelism to process the partitions.
     *
     * @param a the array to be sorted
     * @param parallelism the parallelism level
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    static void sort(long[] a, int parallelism, int low, int high) {
        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {
            new Sorter(a, parallelism, low, high - low, 0).invoke();
        } else {
            sort(null, a, 0, low, high);
        }
    }

    /**
     * Sorts the specified range of the array using Dual-Pivot Quicksort.
     *
     * @param sorter parallel context
     * @param a the array to be sorted
     * @param bits the combination of recursion depth and bit flag, where
     *        the right bit "0" indicates that range is the leftmost part
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    static void sort(Sorter sorter, long[] a, int bits, int low, int high) {
        while (true) {
            int end = high - 1, size = high - low;

            /*
             * Run mixed insertion sort on small non-leftmost parts.
             */
            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {
                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);
                return;
            }

            /*
             * Invoke insertion sort on small leftmost part.
             */
            if (size < MAX_INSERTION_SORT_SIZE) {
                insertionSort(a, low, high, (bits & 1) == 0);
                return;
            }

            /*
             * Check if the whole array or large non-leftmost
             * parts are nearly sorted and then merge runs.
             */
            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)
                    && tryMergingSort(sorter, a, low, size)) {
                return;
            }

            /*
             * Switch to heap sort, if execution time is quadratic.
             */
            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {
                heapSort(a, low, high);
                return;
            }

            /*
             * Use an inexpensive approximation of the golden ratio
             * to select five sample elements and determine pivots.
             */
            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;

            /*
             * Five elements around (and including) the central element
             * will be used for pivot selection as described below. The
             * unequal choice of spacing these elements was empirically
             * determined to work well on a wide variety of inputs.
             */
            int e1 = low + step;
            int e5 = end - step;
            int e3 = (e1 + e5) >>> 1;
            int e2 = (e1 + e3) >>> 1;
            int e4 = (e3 + e5) >>> 1;
            long a3 = a[e3];

            boolean isRandom =
                    a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];

            /*
             * Sort these elements in place by the combination
             * of 4-element sorting network and insertion sort.
             *
             *    1  ------------o-----o------------
             *                   |     |
             *    2  ------o-----|-----o-----o------
             *             |     |           |
             *    4  ------|-----o-----o-----o------
             *             |           |
             *    5  ------o-----------o------------
             */
            if (a[e2] > a[e5]) { long t = a[e2]; a[e2] = a[e5]; a[e5] = t; }
            if (a[e1] > a[e4]) { long t = a[e1]; a[e1] = a[e4]; a[e4] = t; }
            if (a[e1] > a[e2]) { long t = a[e1]; a[e1] = a[e2]; a[e2] = t; }
            if (a[e4] > a[e5]) { long t = a[e4]; a[e4] = a[e5]; a[e5] = t; }
            if (a[e2] > a[e4]) { long t = a[e2]; a[e2] = a[e4]; a[e4] = t; }

            /*
             * Insert the third element.
             */
            if (a3 < a[e2]) {
                if (a3 < a[e1]) {
                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;
                } else {
                    a[e3] = a[e2]; a[e2] = a3;
                }
            } else if (a3 > a[e4]) {
                if (a3 > a[e5]) {
                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;
                } else {
                    a[e3] = a[e4]; a[e4] = a3;
                }
            }

            /*
             * Try Radix sort on large fully random data,
             * taking into account parallel context.
             */
            if (size > MIN_RADIX_SORT_SIZE
                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5] && isRandom
                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)
                    && tryRadixSort(sorter, a, low, high)) {
                return;
            }
            System.out.println("test");
            // Pointers
            int lower = low; // The index of the last element of the left part
            int upper = end; // The index of the first element of the right part

            /*
             * Partitioning with two pivots on array of random elements.
             */
            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {

                /*
                 * Use the first and fifth of the five sorted elements as
                 * the pivots. These values are inexpensive approximation
                 * of tertiles. Note, that pivot1 < pivot2.
                 */
                long pivot1 = a[e1];
                long pivot2 = a[e5];

                /*
                 * The first and the last elements to be sorted are moved
                 * to the locations formerly occupied by the pivots. When
                 * partitioning is completed, the pivots are swapped back
                 * into their final positions, and excluded from the next
                 * subsequent sorting.
                 */
                a[e1] = a[lower];
                a[e5] = a[upper];

                /*
                 * Skip elements, which are less or greater than the pivots.
                 */
                while (a[++lower] < pivot1);
                while (a[--upper] > pivot2);

                /*
                 * Backward 3-interval partitioning
                 *
                 *     left part                    central part          right part
                 * +------------------------------------------------------------------+
                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |
                 * +------------------------------------------------------------------+
                 *               ^         ^                            ^
                 *               |         |                            |
                 *             lower       k                          upper
                 *
                 * Pointer k is the last index of ?-part
                 * Pointer lower is the last index of left part
                 * Pointer upper is the first index of right part
                 *
                 * Invariants:
                 *
                 *     all in (low, lower]  <  pivot1
                 *     all in (k, upper)   in [pivot1, pivot2]
                 *     all in [upper, end)  >  pivot2
                 */
                for (int unused = --lower, k = ++upper; --k > lower; ) {
                    long ak = a[k];

                    if (ak < pivot1) { // Move a[k] to the left side
                        while (a[++lower] < pivot1) {
                            if (lower == k) {
                                break;
                            }
                        }
                        if (a[lower] > pivot2) {
                            a[k] = a[--upper];
                            a[upper] = a[lower];
                        } else {
                            a[k] = a[lower];
                        }
                        a[lower] = ak;
                    } else if (ak > pivot2) { // Move a[k] to the right side
                        a[k] = a[--upper];
                        a[upper] = ak;
                    }
                }

                /*
                 * Swap the pivots into their final positions.
                 */
                a[low] = a[lower]; a[lower] = pivot1;
                a[end] = a[upper]; a[upper] = pivot2;

                /*
                 * Sort non-left parts recursively (possibly in parallel),
                 * excluding known pivots.
                 */
                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {
                    sorter.forkSorter(bits | 1, lower + 1, upper);
                    sorter.forkSorter(bits | 1, upper + 1, high);
                } else {
                    sort(sorter, a, bits | 1, lower + 1, upper);
                    sort(sorter, a, bits | 1, upper + 1, high);
                }

            } else { // Partitioning with one pivot

                /*
                 * Use the third of the five sorted elements as the pivot.
                 * This value is inexpensive approximation of the median.
                 */
                long pivot = a[e3];

                /*
                 * The first element to be sorted is moved to the
                 * location formerly occupied by the pivot. After
                 * completion of partitioning the pivot is swapped
                 * back into its final position, and excluded from
                 * the next subsequent sorting.
                 */
                a[e3] = a[lower];

                /*
                 * Dutch National Flag partitioning
                 *
                 *    left part                central part    right part
                 * +------------------------------------------------------+
                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |
                 * +------------------------------------------------------+
                 *              ^           ^                ^
                 *              |           |                |
                 *            lower         k              upper
                 *
                 * Pointer k is the last index of ?-part
                 * Pointer lower is the last index of left part
                 * Pointer upper is the first index of right part
                 *
                 * Invariants:
                 *
                 *     all in (low, lower]  <  pivot
                 *     all in (k, upper)   ==  pivot
                 *     all in [upper, end]  >  pivot
                 */
                for (int k = ++upper; --k > lower; ) {
                    long ak = a[k];

                    if (ak != pivot) {
                        a[k] = pivot;

                        if (ak < pivot) { // Move a[k] to the left side
                            while (a[++lower] < pivot);

                            if (a[lower] > pivot) {
                                a[--upper] = a[lower];
                            }
                            a[lower] = ak;
                        } else { // ak > pivot - Move a[k] to the right side
                            a[--upper] = ak;
                        }
                    }
                }

                /*
                 * Swap the pivot into its final position.
                 */
                a[low] = a[lower]; a[lower] = pivot;

                /*
                 * Sort the right part (possibly in parallel), excluding
                 * known pivot. All elements from the central part are
                 * equal and therefore already sorted.
                 */
                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {
                    sorter.forkSorter(bits | 1, upper, high);
                } else {
                    sort(sorter, a, bits | 1, upper, high);
                }
            }
            high = lower; // Iterate along the left part
        }
    }

    /**
     * Sorts the specified range of the array using mixed insertion sort.
     *
     * Mixed insertion sort is combination of pin insertion sort,
     * simple insertion sort and pair insertion sort.
     *
     * In the context of Dual-Pivot Quicksort, the pivot element
     * from the left part plays the role of sentinel, because it
     * is less than any elements from the given part. Therefore,
     * expensive check of the left range can be skipped on each
     * iteration unless it is the leftmost call.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param end the index of the last element for simple insertion sort
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void mixedInsertionSort(long[] a, int low, int end, int high) {

        /*
         * Start with pin insertion sort.
         */
        for (int i, p = high; ++low < end && low < p; ) {
            long ai = a[i = low];

            /*
             * Find pin element, smaller than the given element.
             */
            while (ai < a[--p]);

            /*
             * Swap these elements.
             */
            ai = a[p]; a[p] = a[i];

            /*
             * Insert element into sorted part.
             */
            while (ai < a[--i]) {
                a[i + 1] = a[i];
            }
            a[i + 1] = ai;
        }

        /*
         * Continue with simple insertion sort.
         */
        for (int i; low < end; ++low) {
            long ai = a[i = low];

            /*
             * Insert element into sorted part.
             */
            while (ai < a[--i]) {
                a[i + 1] = a[i];
            }
            a[i + 1] = ai;
        }

        /*
         * Finish with pair insertion sort.
         */
        for (int i; low < high; ++low) {
            long a1 = a[i = low], a2 = a[++low];

            /*
             * Insert two elements per iteration: at first, insert the
             * larger element and then insert the smaller element, but
             * from the position where the larger element was inserted.
             */
            if (a1 > a2) {

                while (a1 < a[--i]) {
                    a[i + 2] = a[i];
                }
                a[++i + 1] = a1;

                while (a2 < a[--i]) {
                    a[i + 1] = a[i];
                }
                a[i + 1] = a2;

            } else if (a1 < a[i - 1]) {

                while (a2 < a[--i]) {
                    a[i + 2] = a[i];
                }
                a[++i + 1] = a2;

                while (a1 < a[--i]) {
                    a[i + 1] = a[i];
                }
                a[i + 1] = a1;
            }
        }
    }

    /**
     * Sorts the specified range of the array using insertion sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     * @param leftmost indicates that the range is the leftmost part
     */
    private static void insertionSort(long[] a, int low, int high, boolean leftmost) {
        if (leftmost) {
            for (int i, k = low; ++k < high; ) {
                long ai = a[i = k];

                if (ai < a[i - 1]) {
                    while (--i >= low && ai < a[i]) {
                        a[i + 1] = a[i];
                    }
                    a[i + 1] = ai;
                }
            }
        } else {
            for (int i; ++low < high; ) {
                long ai = a[i = low];

                while (ai < a[--i]) {
                    a[i + 1] = a[i];
                }
                a[i + 1] = ai;
            }
        }
    }

    /**
     * Tries to sort the specified range of the array
     * using LSD (Least Significant Digit) Radix sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     * @return {@code true} if the array is finally sorted, otherwise {@code false}
     */
    static boolean tryRadixSort(Sorter sorter, long[] a, int low, int high) {
        long[] b; int offset = low, size = high - low;

        /*
         * Allocate additional buffer.
         */
        if (sorter != null && (b = (long[]) sorter.b) != null) {
            offset = sorter.offset;
        } else {
            if ((b = (long[]) tryAllocate(a, size)) == null) {
                return false;
            }
        }

        int start = low - offset;
        int last = high - offset;

        /*
         * Count the number of all digits.
         */
        int[] count1 = new int[1024];
        int[] count2 = new int[2048];
        int[] count3 = new int[2048];
        int[] count4 = new int[2048];
        int[] count5 = new int[2048];
        int[] count6 = new int[1024];

        for (int i = low; i < high; ++i) {
            count1[(int)  (a[i]         & 0x3FF)]--;
            count2[(int) ((a[i] >>> 10) & 0x7FF)]--;
            count3[(int) ((a[i] >>> 21) & 0x7FF)]--;
            count4[(int) ((a[i] >>> 32) & 0x7FF)]--;
            count5[(int) ((a[i] >>> 43) & 0x7FF)]--;
            count6[(int) ((a[i] >>> 54) ^ 0x200)]--; // Reverse the sign bit
        }

        /*
         * Detect digits to be processed.
         */
        boolean processDigit1 = processDigit(count1, 1023, -size, high);
        boolean processDigit2 = processDigit(count2, 2047, -size, high);
        boolean processDigit3 = processDigit(count3, 2047, -size, high);
        boolean processDigit4 = processDigit(count4, 2047, -size, high);
        boolean processDigit5 = processDigit(count5, 2047, -size, high);
        boolean processDigit6 = processDigit(count6, 1023, -size, high);

        /*
         * Process the 1-st digit.
         */
        if (processDigit1) {
            for (int i = low; i < high; ++i) {
                b[count1[(int) (a[i] & 0x3FF)]++ - offset] = a[i];
            }
        }

        /*
         * Process the 2-nd digit.
         */
        if (processDigit2) {
            if (processDigit1) {
                for (int i = start; i < last; ++i) {
                    a[count2[(int) ((b[i] >>> 10) & 0x7FF)]++] = b[i];
                }
            } else {
                for (int i = low; i < high; ++i) {
                    b[count2[(int) ((a[i] >>> 10) & 0x7FF)]++ - offset] = a[i];
                }
            }
        }

        /*
         * Process the 3-rd digit.
         */
        if (processDigit3) {
            if (processDigit1 ^ processDigit2) {
                for (int i = start; i < last; ++i) {
                    a[count3[(int) ((b[i] >>> 21) & 0x7FF)]++] = b[i];
                }
            } else {
                for (int i = low; i < high; ++i) {
                    b[count3[(int) ((a[i] >>> 21) & 0x7FF)]++ - offset] = a[i];
                }
            }
        }

        /*
         * Process the 4-th digit.
         */
        if (processDigit4) {
            if (processDigit1 ^ processDigit2 ^ processDigit3) {
                for (int i = start; i < last; ++i) {
                    a[count4[(int) ((b[i] >>> 32) & 0x7FF)]++] = b[i];
                }
            } else {
                for (int i = low; i < high; ++i) {
                    b[count4[(int) ((a[i] >>> 32) & 0x7FF)]++ - offset] = a[i];
                }
            }
        }

        /*
         * Process the 5-th digit.
         */
        if (processDigit5) {
            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {
                for (int i = start; i < last; ++i) {
                    a[count5[(int) ((b[i] >>> 43) & 0x7FF)]++] = b[i];
                }
            } else {
                for (int i = low; i < high; ++i) {
                    b[count5[(int) ((a[i] >>> 43) & 0x7FF)]++ - offset] = a[i];
                }
            }
        }

        /*
         * Process the 6-th digit.
         */
        if (processDigit6) {
            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {
                for (int i = start; i < last; ++i) {
                    a[count6[(int) ((b[i] >>> 54) ^ 0x200)]++] = b[i];
                }
            } else {
                for (int i = low; i < high; ++i) {
                    b[count6[(int) ((a[i] >>> 54) ^ 0x200)]++ - offset] = a[i];
                }
            }
        }

        /*
         * Copy the buffer to original array, if we process ood number of digits.
         */
        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {
            System.arraycopy(b, low - offset, a, low, size);
        }
        return true;
    }


    /**
     * Sorts the specified range of the array using heap sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void heapSort(long[] a, int low, int high) {
        for (int k = (low + high) >>> 1; k > low; ) {
            pushDown(a, --k, a[k], low, high);
        }
        while (--high > low) {
            long max = a[low];
            pushDown(a, low, a[high], low, high);
            a[high] = max;
        }
    }

    /**
     * Pushes specified element down during heap sort.
     *
     * @param a the given array
     * @param p the start index
     * @param value the given element
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void pushDown(long[] a, int p, long value, int low, int high) {
        for (int k ;; a[p] = a[p = k]) {
            k = (p << 1) - low + 2; // Index of the right child

            if (k > high) {
                break;
            }
            if (k == high || a[k] < a[k - 1]) {
                --k;
            }
            if (a[k] <= value) {
                break;
            }
        }
        a[p] = value;
    }

    /**
     * Tries to sort the specified range of the array using merging sort.
     *
     * @param sorter parallel context
     * @param a the array to be sorted
     * @param low the index of the first element to be sorted
     * @param size the array size
     * @return {@code true} if the array is finally sorted, otherwise {@code false}
     */
    private static boolean tryMergingSort(Sorter sorter, long[] a, int low, int size) {

        /*
         * The run array is constructed only if initial runs are
         * long enough to continue, run[i] then holds start index
         * of the i-th sequence of elements in non-descending order.
         */
        int[] run = null;
        int high = low + size;
        int count = 1, last = low;

        /*
         * Identify all possible runs.
         */
        for (int k = low + 1; k < high; ) {

            /*
             * Find the end index of the current run.
             */
            if (a[k - 1] < a[k]) {

                // Identify ascending sequence
                while (++k < high && a[k - 1] <= a[k]);

            } else if (a[k - 1] > a[k]) {

                // Identify descending sequence
                while (++k < high && a[k - 1] >= a[k]);

                // Reverse into ascending order
                for (int i = last - 1, j = k; ++i < --j && a[i] > a[j]; ) {
                    long ai = a[i]; a[i] = a[j]; a[j] = ai;
                }
            } else { // Identify constant sequence
                for (long ak = a[k]; ++k < high && ak == a[k]; );

                if (k < high) {
                    continue;
                }
            }

            /*
             * Check special cases.
             */
            if (run == null) {
                if (k == high) {
                    /*
                     * The array is monotonous sequence,
                     * and therefore already sorted.
                     */
                    return true;
                }

                if (k - low < MIN_FIRST_RUN_SIZE) {
                    /*
                     * The first run is too small
                     * to proceed with scanning.
                     */
                    return false;
                }

                // Initial min 127, max 1023, extended to 5120
                run = new int[((size >> 10) | 0x7F) & 0x3FF];
                run[0] = low;

            } else if (a[last - 1] > a[last]) { // Start new run

                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {
                    /*
                     * The first runs are not long
                     * enough to continue scanning.
                     */
                    return false;
                }

                if (++count == MAX_RUN_CAPACITY) {
                    /*
                     * Array is not highly structured.
                     */
                    return false;
                }

                if (count == run.length) {
                    /*
                     * Increase capacity of index array.
                     */
                    run = Arrays.copyOf(run, count << 1);
                }
            }
            run[count] = (last = k);

            if (++k == high) {
                /*
                 * This is single-element run at the end.
                 */
                --k;
            }
        }

        /*
         * Merge runs of highly structured array.
         */
        if (count > 1) {
            long[] b; int offset = low;

            if (sorter != null && (b = (long[]) sorter.b) != null) {
                offset = sorter.offset;
            } else {
                if ((b = (long[]) tryAllocate(a, size)) == null) {
                    return false;
                }
            }
            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);
        }
        return true;
    }

    /**
     * Merges the specified runs.
     *
     * @param a the source array
     * @param b the temporary buffer used in merging
     * @param offset the start index in the source, inclusive
     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)
     * @param parallel indicates whether merging is performed in parallel
     * @param run the start indexes of the runs, inclusive
     * @param lo the start index of the first run, inclusive
     * @param hi the start index of the last run, inclusive
     * @return the destination where runs are merged
     */
    private static long[] mergeRuns(long[] a, long[] b, int offset,
                                    int aim, boolean parallel, int[] run, int lo, int hi) {

        if (hi - lo == 1) {
            if (aim >= 0) {
                return a;
            }
            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);
            return b;
        }

        /*
         * Split into approximately equal parts.
         */
        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;
        while (run[++mi + 1] <= rmi);

        /*
         * Merge the left and right parts.
         */
        long[] a1, a2;

        if (parallel && hi - lo > MIN_RUN_COUNT) {
            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();
            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);
            a2 = (long[]) merger.getDestination();
        } else {
            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);
            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);
        }

        long[] dst = a1 == a ? b : a;

        int k   = a1 == a ? run[lo] - offset : run[lo];
        int lo1 = a1 == b ? run[lo] - offset : run[lo];
        int hi1 = a1 == b ? run[mi] - offset : run[mi];
        int lo2 = a2 == b ? run[mi] - offset : run[mi];
        int hi2 = a2 == b ? run[hi] - offset : run[hi];

        if (parallel) {
            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();
        } else {
            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);
        }
        return dst;
    }

    /**
     * Merges the sorted parts.
     *
     * @param merger parallel context
     * @param dst the destination where parts are merged
     * @param k the start index of the destination, inclusive
     * @param a1 the first part
     * @param lo1 the start index of the first part, inclusive
     * @param hi1 the end index of the first part, exclusive
     * @param a2 the second part
     * @param lo2 the start index of the second part, inclusive
     * @param hi2 the end index of the second part, exclusive
     */
    private static void mergeParts(Merger merger, long[] dst, int k,
                                   long[] a1, int lo1, int hi1, long[] a2, int lo2, int hi2) {

        if (merger != null && a1 == a2) {

            while (true) {

                /*
                 * The first part must be larger.
                 */
                if (hi1 - lo1 < hi2 - lo2) {
                    int lo = lo1; lo1 = lo2; lo2 = lo;
                    int hi = hi1; hi1 = hi2; hi2 = hi;
                }

                /*
                 * Small parts will be merged sequentially.
                 */
                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {
                    break;
                }

                /*
                 * Find the median of the larger part.
                 */
                int mi1 = (lo1 + hi1) >>> 1;
                long key = a1[mi1];
                int mi2 = hi2;

                /*
                 * Partition the smaller part.
                 */
                for (int loo = lo2; loo < mi2; ) {
                    int t = (loo + mi2) >>> 1;

                    if (key > a2[t]) {
                        loo = t + 1;
                    } else {
                        mi2 = t;
                    }
                }

                /*
                 * Reserve space for the left sub-parts.
                 */
                int d = mi2 - lo2 + mi1 - lo1;

                /*
                 * Merge the right sub-parts in parallel.
                 */
                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);

                /*
                 * Process the sub-left parts.
                 */
                hi1 = mi1;
                hi2 = mi2;
            }
        }

        /*
         * Merge small parts sequentially.
         */
        while (lo1 < hi1 && lo2 < hi2) {
            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];
        }
        if (dst != a1 || k < lo1) {
            while (lo1 < hi1) {
                dst[k++] = a1[lo1++];
            }
        }
        if (dst != a2 || k < lo2) {
            while (lo2 < hi2) {
                dst[k++] = a2[lo2++];
            }
        }
    }

// #[byte]

    /**
     * Sorts the specified range of the array using
     * counting sort or insertion sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    static void sort(byte[] a, int low, int high) {
        if (high - low > MIN_BYTE_COUNTING_SORT_SIZE) {
            countingSort(a, low, high);
        } else {
            insertionSort(a, low, high);
        }
    }

    /**
     * Sorts the specified range of the array using insertion sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void insertionSort(byte[] a, int low, int high) {
        for (int i, k = low; ++k < high; ) {
            byte ai = a[i = k];

            if (ai < a[i - 1]) {
                while (--i >= low && ai < a[i]) {
                    a[i + 1] = a[i];
                }
                a[i + 1] = ai;
            }
        }
    }

    /**
     * The number of distinct byte values.
     */
    private static final int NUM_BYTE_VALUES = 1 << 8;

    /**
     * Max index of byte counter.
     */
    private static final int MAX_BYTE_INDEX = Byte.MAX_VALUE + NUM_BYTE_VALUES + 1;

    /**
     * Sorts the specified range of the array using counting sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */

    private static void countingSort(byte[] a, int low, int high) {
        int[] count = new int[NUM_BYTE_VALUES];

        /*
         * Compute the histogram for all values.
         */
        for (int i = high; i > low; ++count[a[--i] & 0xFF]);

        /*
         * Put values on their final positions.
         */
        if (high - low > NUM_BYTE_VALUES) {
            for (int i = MAX_BYTE_INDEX; --i > Byte.MAX_VALUE; ) {
                int value = i & 0xFF;

                for (low = high - count[value]; high > low;
                     a[--high] = (byte) value
                );
            }
        } else {
            for (int i = MAX_BYTE_INDEX; high > low; ) {
                while (count[--i & 0xFF] == 0);

                int value = i & 0xFF;
                int c = count[value];

                do {
                    a[--high] = (byte) value;
                } while (--c > 0);
            }
        }
    }

// #[char]

    /**
     * Sorts the specified range of the array using
     * counting sort or Dual-Pivot Quicksort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    static void sort(char[] a, int low, int high) {
        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {
            countingSort(a, low, high);
        } else {
            sort(a, 0, low, high);
        }
    }

    /**
     * Sorts the specified range of the array using Dual-Pivot Quicksort.
     *
     * @param a the array to be sorted
     * @param bits the combination of recursion depth and bit flag, where
     *        the right bit "0" indicates that range is the leftmost part
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    static void sort(char[] a, int bits, int low, int high) {
        while (true) {
            int end = high - 1, size = high - low;

            /*
             * Invoke insertion sort on small leftmost part.
             */
            if (size < MAX_INSERTION_SORT_SIZE) {
                insertionSort(a, low, high);
                return;
            }

            /*
             * Switch to counting sort, if execution time is quadratic.
             */
            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {
                countingSort(a, low, high);
                return;
            }

            /*
             * Use an inexpensive approximation of the golden ratio
             * to select five sample elements and determine pivots.
             */
            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;

            /*
             * Five elements around (and including) the central element
             * will be used for pivot selection as described below. The
             * unequal choice of spacing these elements was empirically
             * determined to work well on a wide variety of inputs.
             */
            int e1 = low + step;
            int e5 = end - step;
            int e3 = (e1 + e5) >>> 1;
            int e2 = (e1 + e3) >>> 1;
            int e4 = (e3 + e5) >>> 1;
            char a3 = a[e3];

            /*
             * Sort these elements in place by the combination
             * of 4-element sorting network and insertion sort.
             *
             *    1  ------------o-----o------------
             *                   |     |
             *    2  ------o-----|-----o-----o------
             *             |     |           |
             *    4  ------|-----o-----o-----o------
             *             |           |
             *    5  ------o-----------o------------
             */
            if (a[e2] > a[e5]) { char t = a[e2]; a[e2] = a[e5]; a[e5] = t; }
            if (a[e1] > a[e4]) { char t = a[e1]; a[e1] = a[e4]; a[e4] = t; }
            if (a[e1] > a[e2]) { char t = a[e1]; a[e1] = a[e2]; a[e2] = t; }
            if (a[e4] > a[e5]) { char t = a[e4]; a[e4] = a[e5]; a[e5] = t; }
            if (a[e2] > a[e4]) { char t = a[e2]; a[e2] = a[e4]; a[e4] = t; }

            /*
             * Insert the third element.
             */
            if (a3 < a[e2]) {
                if (a3 < a[e1]) {
                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;
                } else {
                    a[e3] = a[e2]; a[e2] = a3;
                }
            } else if (a3 > a[e4]) {
                if (a3 > a[e5]) {
                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;
                } else {
                    a[e3] = a[e4]; a[e4] = a3;
                }
            }

            // Pointers
            int lower = low; // The index of the last element of the left part
            int upper = end; // The index of the first element of the right part

            /*
             * Partitioning with two pivots on array of random elements.
             */
            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {

                /*
                 * Use the first and fifth of the five sorted elements as
                 * the pivots. These values are inexpensive approximation
                 * of tertiles. Note, that pivot1 < pivot2.
                 */
                char pivot1 = a[e1];
                char pivot2 = a[e5];

                /*
                 * The first and the last elements to be sorted are moved
                 * to the locations formerly occupied by the pivots. When
                 * partitioning is completed, the pivots are swapped back
                 * into their final positions, and excluded from the next
                 * subsequent sorting.
                 */
                a[e1] = a[lower];
                a[e5] = a[upper];

                /*
                 * Skip elements, which are less or greater than the pivots.
                 */
                while (a[++lower] < pivot1);
                while (a[--upper] > pivot2);

                /*
                 * Backward 3-interval partitioning
                 *
                 *     left part                    central part          right part
                 * +------------------------------------------------------------------+
                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |
                 * +------------------------------------------------------------------+
                 *               ^         ^                            ^
                 *               |         |                            |
                 *             lower       k                          upper
                 *
                 * Pointer k is the last index of ?-part
                 * Pointer lower is the last index of left part
                 * Pointer upper is the first index of right part
                 *
                 * Invariants:
                 *
                 *     all in (low, lower]  <  pivot1
                 *     all in (k, upper)   in [pivot1, pivot2]
                 *     all in [upper, end)  >  pivot2
                 */
                for (int unused = --lower, k = ++upper; --k > lower; ) {
                    char ak = a[k];

                    if (ak < pivot1) { // Move a[k] to the left side
                        while (a[++lower] < pivot1) {
                            if (lower == k) {
                                break;
                            }
                        }
                        if (a[lower] > pivot2) {
                            a[k] = a[--upper];
                            a[upper] = a[lower];
                        } else {
                            a[k] = a[lower];
                        }
                        a[lower] = ak;
                    } else if (ak > pivot2) { // Move a[k] to the right side
                        a[k] = a[--upper];
                        a[upper] = ak;
                    }
                }

                /*
                 * Swap the pivots into their final positions.
                 */
                a[low] = a[lower]; a[lower] = pivot1;
                a[end] = a[upper]; a[upper] = pivot2;

                /*
                 * Sort non-left parts recursively,
                 * excluding known pivots.
                 */
                sort(a, bits | 1, lower + 1, upper);
                sort(a, bits | 1, upper + 1, high);

            } else { // Partitioning with one pivot

                /*
                 * Use the third of the five sorted elements as the pivot.
                 * This value is inexpensive approximation of the median.
                 */
                char pivot = a[e3];

                /*
                 * The first element to be sorted is moved to the
                 * location formerly occupied by the pivot. After
                 * completion of partitioning the pivot is swapped
                 * back into its final position, and excluded from
                 * the next subsequent sorting.
                 */
                a[e3] = a[lower];

                /*
                 * Dutch National Flag partitioning
                 *
                 *    left part                central part    right part
                 * +------------------------------------------------------+
                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |
                 * +------------------------------------------------------+
                 *              ^           ^                ^
                 *              |           |                |
                 *            lower         k              upper
                 *
                 * Pointer k is the last index of ?-part
                 * Pointer lower is the last index of left part
                 * Pointer upper is the first index of right part
                 *
                 * Invariants:
                 *
                 *     all in (low, lower]  <  pivot
                 *     all in (k, upper)   ==  pivot
                 *     all in [upper, end]  >  pivot
                 */
                for (int k = ++upper; --k > lower; ) {
                    char ak = a[k];

                    if (ak != pivot) {
                        a[k] = pivot;

                        if (ak < pivot) { // Move a[k] to the left side
                            while (a[++lower] < pivot);

                            if (a[lower] > pivot) {
                                a[--upper] = a[lower];
                            }
                            a[lower] = ak;
                        } else { // ak > pivot - Move a[k] to the right side
                            a[--upper] = ak;
                        }
                    }
                }

                /*
                 * Swap the pivot into its final position.
                 */
                a[low] = a[lower]; a[lower] = pivot;

                /*
                 * Sort the right part, excluding known pivot.
                 * All elements from the central part are
                 * equal and therefore already sorted.
                 */
                sort(a, bits | 1, upper, high);
            }
            high = lower; // Iterate along the left part
        }
    }

    /**
     * Sorts the specified range of the array using insertion sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void insertionSort(char[] a, int low, int high) {
        for (int i, k = low; ++k < high; ) {
            char ai = a[i = k];

            if (ai < a[i - 1]) {
                while (--i >= low && ai < a[i]) {
                    a[i + 1] = a[i];
                }
                a[i + 1] = ai;
            }
        }
    }

    /**
     * The number of distinct char values.
     */
    private static final int NUM_CHAR_VALUES = 1 << 16;

    /**
     * Sorts the specified range of the array using counting sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void countingSort(char[] a, int low, int high) {
        int[] count = new int[NUM_CHAR_VALUES];

        /*
         * Compute the histogram for all values.
         */
        for (int i = high; i > low; ++count[a[--i]]);

        /*
         * Put values on their final positions.
         */
        if (high - low > NUM_CHAR_VALUES) {
            for (int i = NUM_CHAR_VALUES; i > 0; ) {
                for (low = high - count[--i]; high > low;
                     a[--high] = (char) i
                );
            }
        } else {
            for (int i = NUM_CHAR_VALUES; high > low; ) {
                while (count[--i] == 0);
                int c = count[i];

                do {
                    a[--high] = (char) i;
                } while (--c > 0);
            }
        }
    }

// #[short]

    /**
     * Sorts the specified range of the array using
     * counting sort or Dual-Pivot Quicksort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    static void sort(short[] a, int low, int high) {
        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {
            countingSort(a, low, high);
        } else {
            sort(a, 0, low, high);
        }
    }

    /**
     * Sorts the specified range of the array using Dual-Pivot Quicksort.
     *
     * @param a the array to be sorted
     * @param bits the combination of recursion depth and bit flag, where
     *        the right bit "0" indicates that range is the leftmost part
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    static void sort(short[] a, int bits, int low, int high) {
        while (true) {
            int end = high - 1, size = high - low;

            /*
             * Invoke insertion sort on small leftmost part.
             */
            if (size < MAX_INSERTION_SORT_SIZE) {
                insertionSort(a, low, high);
                return;
            }

            /*
             * Switch to counting sort, if execution time is quadratic.
             */
            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {
                countingSort(a, low, high);
                return;
            }

            /*
             * Use an inexpensive approximation of the golden ratio
             * to select five sample elements and determine pivots.
             */
            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;

            /*
             * Five elements around (and including) the central element
             * will be used for pivot selection as described below. The
             * unequal choice of spacing these elements was empirically
             * determined to work well on a wide variety of inputs.
             */
            int e1 = low + step;
            int e5 = end - step;
            int e3 = (e1 + e5) >>> 1;
            int e2 = (e1 + e3) >>> 1;
            int e4 = (e3 + e5) >>> 1;
            short a3 = a[e3];

            /*
             * Sort these elements in place by the combination
             * of 4-element sorting network and insertion sort.
             *
             *    1  ------------o-----o------------
             *                   |     |
             *    2  ------o-----|-----o-----o------
             *             |     |           |
             *    4  ------|-----o-----o-----o------
             *             |           |
             *    5  ------o-----------o------------
             */
            if (a[e2] > a[e5]) { short t = a[e2]; a[e2] = a[e5]; a[e5] = t; }
            if (a[e1] > a[e4]) { short t = a[e1]; a[e1] = a[e4]; a[e4] = t; }
            if (a[e1] > a[e2]) { short t = a[e1]; a[e1] = a[e2]; a[e2] = t; }
            if (a[e4] > a[e5]) { short t = a[e4]; a[e4] = a[e5]; a[e5] = t; }
            if (a[e2] > a[e4]) { short t = a[e2]; a[e2] = a[e4]; a[e4] = t; }

            /*
             * Insert the third element.
             */
            if (a3 < a[e2]) {
                if (a3 < a[e1]) {
                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;
                } else {
                    a[e3] = a[e2]; a[e2] = a3;
                }
            } else if (a3 > a[e4]) {
                if (a3 > a[e5]) {
                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;
                } else {
                    a[e3] = a[e4]; a[e4] = a3;
                }
            }

            // Pointers
            int lower = low; // The index of the last element of the left part
            int upper = end; // The index of the first element of the right part

            /*
             * Partitioning with two pivots on array of random elements.
             */
            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {

                /*
                 * Use the first and fifth of the five sorted elements as
                 * the pivots. These values are inexpensive approximation
                 * of tertiles. Note, that pivot1 < pivot2.
                 */
                short pivot1 = a[e1];
                short pivot2 = a[e5];

                /*
                 * The first and the last elements to be sorted are moved
                 * to the locations formerly occupied by the pivots. When
                 * partitioning is completed, the pivots are swapped back
                 * into their final positions, and excluded from the next
                 * subsequent sorting.
                 */
                a[e1] = a[lower];
                a[e5] = a[upper];

                /*
                 * Skip elements, which are less or greater than the pivots.
                 */
                while (a[++lower] < pivot1);
                while (a[--upper] > pivot2);

                /*
                 * Backward 3-interval partitioning
                 *
                 *     left part                    central part          right part
                 * +------------------------------------------------------------------+
                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |
                 * +------------------------------------------------------------------+
                 *               ^         ^                            ^
                 *               |         |                            |
                 *             lower       k                          upper
                 *
                 * Pointer k is the last index of ?-part
                 * Pointer lower is the last index of left part
                 * Pointer upper is the first index of right part
                 *
                 * Invariants:
                 *
                 *     all in (low, lower]  <  pivot1
                 *     all in (k, upper)   in [pivot1, pivot2]
                 *     all in [upper, end)  >  pivot2
                 */
                for (int unused = --lower, k = ++upper; --k > lower; ) {
                    short ak = a[k];

                    if (ak < pivot1) { // Move a[k] to the left side
                        while (a[++lower] < pivot1) {
                            if (lower == k) {
                                break;
                            }
                        }
                        if (a[lower] > pivot2) {
                            a[k] = a[--upper];
                            a[upper] = a[lower];
                        } else {
                            a[k] = a[lower];
                        }
                        a[lower] = ak;
                    } else if (ak > pivot2) { // Move a[k] to the right side
                        a[k] = a[--upper];
                        a[upper] = ak;
                    }
                }

                /*
                 * Swap the pivots into their final positions.
                 */
                a[low] = a[lower]; a[lower] = pivot1;
                a[end] = a[upper]; a[upper] = pivot2;

                /*
                 * Sort non-left parts recursively,
                 * excluding known pivots.
                 */
                sort(a, bits | 1, lower + 1, upper);
                sort(a, bits | 1, upper + 1, high);

            } else { // Partitioning with one pivot

                /*
                 * Use the third of the five sorted elements as the pivot.
                 * This value is inexpensive approximation of the median.
                 */
                short pivot = a[e3];

                /*
                 * The first element to be sorted is moved to the
                 * location formerly occupied by the pivot. After
                 * completion of partitioning the pivot is swapped
                 * back into its final position, and excluded from
                 * the next subsequent sorting.
                 */
                a[e3] = a[lower];

                /*
                 * Dutch National Flag partitioning
                 *
                 *    left part                central part    right part
                 * +------------------------------------------------------+
                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |
                 * +------------------------------------------------------+
                 *              ^           ^                ^
                 *              |           |                |
                 *            lower         k              upper
                 *
                 * Pointer k is the last index of ?-part
                 * Pointer lower is the last index of left part
                 * Pointer upper is the first index of right part
                 *
                 * Invariants:
                 *
                 *     all in (low, lower]  <  pivot
                 *     all in (k, upper)   ==  pivot
                 *     all in [upper, end]  >  pivot
                 */
                for (int k = ++upper; --k > lower; ) {
                    short ak = a[k];

                    if (ak != pivot) {
                        a[k] = pivot;

                        if (ak < pivot) { // Move a[k] to the left side
                            while (a[++lower] < pivot);

                            if (a[lower] > pivot) {
                                a[--upper] = a[lower];
                            }
                            a[lower] = ak;
                        } else { // ak > pivot - Move a[k] to the right side
                            a[--upper] = ak;
                        }
                    }
                }

                /*
                 * Swap the pivot into its final position.
                 */
                a[low] = a[lower]; a[lower] = pivot;

                /*
                 * Sort the right part, excluding known pivot.
                 * All elements from the central part are
                 * equal and therefore already sorted.
                 */
                sort(a, bits | 1, upper, high);
            }
            high = lower; // Iterate along the left part
        }
    }

    /**
     * Sorts the specified range of the array using insertion sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void insertionSort(short[] a, int low, int high) {
        for (int i, k = low; ++k < high; ) {
            short ai = a[i = k];

            if (ai < a[i - 1]) {
                while (--i >= low && ai < a[i]) {
                    a[i + 1] = a[i];
                }
                a[i + 1] = ai;
            }
        }
    }

    /**
     * The number of distinct short values.
     */
    private static final int NUM_SHORT_VALUES = 1 << 16;

    /**
     * Max index of short counter.
     */
    private static final int MAX_SHORT_INDEX = Short.MAX_VALUE + NUM_SHORT_VALUES + 1;

    /**
     * Sorts the specified range of the array using counting sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void countingSort(short[] a, int low, int high) {
        int[] count = new int[NUM_SHORT_VALUES];

        /*
         * Compute the histogram for all values.
         */
        for (int i = high; i > low; ++count[a[--i] & 0xFFFF]);

        /*
         * Put values on their final positions.
         */
        if (high - low > NUM_SHORT_VALUES) {
            for (int i = MAX_SHORT_INDEX; --i > Short.MAX_VALUE; ) {
                int value = i & 0xFFFF;

                for (low = high - count[value]; high > low;
                     a[--high] = (short) value
                );
            }
        } else {
            for (int i = MAX_SHORT_INDEX; high > low; ) {
                while (count[--i & 0xFFFF] == 0);

                int value = i & 0xFFFF;
                int c = count[value];

                do {
                    a[--high] = (short) value;
                } while (--c > 0);
            }
        }
    }

// #[float]

    /**
     * Sorts the specified range of the array using parallel merge
     * sort and/or Dual-Pivot Quicksort.
     *
     * To balance the faster splitting and parallelism of merge sort
     * with the faster element partitioning of Quicksort, ranges are
     * subdivided in tiers such that, if there is enough parallelism,
     * the four-way parallel merge is started, still ensuring enough
     * parallelism to process the partitions.
     *
     * @param a the array to be sorted
     * @param parallelism the parallelism level
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    static void sort(float[] a, int parallelism, int low, int high) {
        /*
         * Phase 1. Count the number of negative zero -0.0f,
         * turn them into positive zero, and move all NaNs
         * to the end of the array.
         */
        int numNegativeZero = 0;

        for (int k = high; k > low; ) {
            float ak = a[--k];

            if (ak == 0.0f && Float.floatToRawIntBits(ak) < 0) { // ak is -0.0f
                numNegativeZero += 1;
                a[k] = 0.0f;
            } else if (ak != ak) { // ak is NaN
                a[k] = a[--high];
                a[high] = ak;
            }
        }

        /*
         * Phase 2. Sort everything except NaNs,
         * which are already in place.
         */
        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {
            new Sorter(a, parallelism, low, high - low, 0).invoke();
        } else {
            sort(null, a, 0, low, high);
        }

        /*
         * Phase 3. Turn positive zero 0.0f
         * back into negative zero -0.0f.
         */
        if (++numNegativeZero == 1) {
            return;
        }

        /*
         * Find the position one less than
         * the index of the first zero.
         */
        while (low <= high) {
            int middle = (low + high) >>> 1;

            if (a[middle] < 0) {
                low = middle + 1;
            } else {
                high = middle - 1;
            }
        }

        /*
         * Replace the required number of 0.0f by -0.0f.
         */
        while (--numNegativeZero > 0) {
            a[++high] = -0.0f;
        }
    }

    /**
     * Sorts the specified range of the array using Dual-Pivot Quicksort.
     *
     * @param sorter parallel context
     * @param a the array to be sorted
     * @param bits the combination of recursion depth and bit flag, where
     *        the right bit "0" indicates that range is the leftmost part
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    static void sort(Sorter sorter, float[] a, int bits, int low, int high) {
        while (true) {
            int end = high - 1, size = high - low;

            /*
             * Run mixed insertion sort on small non-leftmost parts.
             */
            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {
                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);
                return;
            }

            /*
             * Invoke insertion sort on small leftmost part.
             */
            if (size < MAX_INSERTION_SORT_SIZE) {
                insertionSort(a, low, high, (bits & 1) == 0);
                return;
            }

            /*
             * Check if the whole array or large non-leftmost
             * parts are nearly sorted and then merge runs.
             */
            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)
                    && tryMergingSort(sorter, a, low, size)) {
                return;
            }

            /*
             * Switch to heap sort, if execution time is quadratic.
             */
            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {
                heapSort(a, low, high);
                return;
            }

            /*
             * Use an inexpensive approximation of the golden ratio
             * to select five sample elements and determine pivots.
             */
            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;

            /*
             * Five elements around (and including) the central element
             * will be used for pivot selection as described below. The
             * unequal choice of spacing these elements was empirically
             * determined to work well on a wide variety of inputs.
             */
            int e1 = low + step;
            int e5 = end - step;
            int e3 = (e1 + e5) >>> 1;
            int e2 = (e1 + e3) >>> 1;
            int e4 = (e3 + e5) >>> 1;
            float a3 = a[e3];

            boolean isRandom =
                    a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];

            /*
             * Sort these elements in place by the combination
             * of 4-element sorting network and insertion sort.
             *
             *    1  ------------o-----o------------
             *                   |     |
             *    2  ------o-----|-----o-----o------
             *             |     |           |
             *    4  ------|-----o-----o-----o------
             *             |           |
             *    5  ------o-----------o------------
             */
            if (a[e2] > a[e5]) { float t = a[e2]; a[e2] = a[e5]; a[e5] = t; }
            if (a[e1] > a[e4]) { float t = a[e1]; a[e1] = a[e4]; a[e4] = t; }
            if (a[e1] > a[e2]) { float t = a[e1]; a[e1] = a[e2]; a[e2] = t; }
            if (a[e4] > a[e5]) { float t = a[e4]; a[e4] = a[e5]; a[e5] = t; }
            if (a[e2] > a[e4]) { float t = a[e2]; a[e2] = a[e4]; a[e4] = t; }

            /*
             * Insert the third element.
             */
            if (a3 < a[e2]) {
                if (a3 < a[e1]) {
                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;
                } else {
                    a[e3] = a[e2]; a[e2] = a3;
                }
            } else if (a3 > a[e4]) {
                if (a3 > a[e5]) {
                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;
                } else {
                    a[e3] = a[e4]; a[e4] = a3;
                }
            }

            /*
             * Try Radix sort on large fully random data,
             * taking into account parallel context.
             */
            if (size > MIN_RADIX_SORT_SIZE
                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5] && isRandom
                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)
                    && tryRadixSort(sorter, a, low, high)) {
                return;
            }

            // Pointers
            int lower = low; // The index of the last element of the left part
            int upper = end; // The index of the first element of the right part

            /*
             * Partitioning with two pivots on array of random elements.
             */
            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {

                /*
                 * Use the first and fifth of the five sorted elements as
                 * the pivots. These values are inexpensive approximation
                 * of tertiles. Note, that pivot1 < pivot2.
                 */
                float pivot1 = a[e1];
                float pivot2 = a[e5];

                /*
                 * The first and the last elements to be sorted are moved
                 * to the locations formerly occupied by the pivots. When
                 * partitioning is completed, the pivots are swapped back
                 * into their final positions, and excluded from the next
                 * subsequent sorting.
                 */
                a[e1] = a[lower];
                a[e5] = a[upper];

                /*
                 * Skip elements, which are less or greater than the pivots.
                 */
                while (a[++lower] < pivot1);
                while (a[--upper] > pivot2);

                /*
                 * Backward 3-interval partitioning
                 *
                 *     left part                    central part          right part
                 * +------------------------------------------------------------------+
                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |
                 * +------------------------------------------------------------------+
                 *               ^         ^                            ^
                 *               |         |                            |
                 *             lower       k                          upper
                 *
                 * Pointer k is the last index of ?-part
                 * Pointer lower is the last index of left part
                 * Pointer upper is the first index of right part
                 *
                 * Invariants:
                 *
                 *     all in (low, lower]  <  pivot1
                 *     all in (k, upper)   in [pivot1, pivot2]
                 *     all in [upper, end)  >  pivot2
                 */
                for (int unused = --lower, k = ++upper; --k > lower; ) {
                    float ak = a[k];

                    if (ak < pivot1) { // Move a[k] to the left side
                        while (a[++lower] < pivot1) {
                            if (lower == k) {
                                break;
                            }
                        }
                        if (a[lower] > pivot2) {
                            a[k] = a[--upper];
                            a[upper] = a[lower];
                        } else {
                            a[k] = a[lower];
                        }
                        a[lower] = ak;
                    } else if (ak > pivot2) { // Move a[k] to the right side
                        a[k] = a[--upper];
                        a[upper] = ak;
                    }
                }

                /*
                 * Swap the pivots into their final positions.
                 */
                a[low] = a[lower]; a[lower] = pivot1;
                a[end] = a[upper]; a[upper] = pivot2;

                /*
                 * Sort non-left parts recursively (possibly in parallel),
                 * excluding known pivots.
                 */
                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {
                    sorter.forkSorter(bits | 1, lower + 1, upper);
                    sorter.forkSorter(bits | 1, upper + 1, high);
                } else {
                    sort(sorter, a, bits | 1, lower + 1, upper);
                    sort(sorter, a, bits | 1, upper + 1, high);
                }

            } else { // Partitioning with one pivot

                /*
                 * Use the third of the five sorted elements as the pivot.
                 * This value is inexpensive approximation of the median.
                 */
                float pivot = a[e3];

                /*
                 * The first element to be sorted is moved to the
                 * location formerly occupied by the pivot. After
                 * completion of partitioning the pivot is swapped
                 * back into its final position, and excluded from
                 * the next subsequent sorting.
                 */
                a[e3] = a[lower];

                /*
                 * Dutch National Flag partitioning
                 *
                 *    left part                central part    right part
                 * +------------------------------------------------------+
                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |
                 * +------------------------------------------------------+
                 *              ^           ^                ^
                 *              |           |                |
                 *            lower         k              upper
                 *
                 * Pointer k is the last index of ?-part
                 * Pointer lower is the last index of left part
                 * Pointer upper is the first index of right part
                 *
                 * Invariants:
                 *
                 *     all in (low, lower]  <  pivot
                 *     all in (k, upper)   ==  pivot
                 *     all in [upper, end]  >  pivot
                 */
                for (int k = ++upper; --k > lower; ) {
                    float ak = a[k];

                    if (ak != pivot) {
                        a[k] = pivot;

                        if (ak < pivot) { // Move a[k] to the left side
                            while (a[++lower] < pivot);

                            if (a[lower] > pivot) {
                                a[--upper] = a[lower];
                            }
                            a[lower] = ak;
                        } else { // ak > pivot - Move a[k] to the right side
                            a[--upper] = ak;
                        }
                    }
                }

                /*
                 * Swap the pivot into its final position.
                 */
                a[low] = a[lower]; a[lower] = pivot;

                /*
                 * Sort the right part (possibly in parallel), excluding
                 * known pivot. All elements from the central part are
                 * equal and therefore already sorted.
                 */
                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {
                    sorter.forkSorter(bits | 1, upper, high);
                } else {
                    sort(sorter, a, bits | 1, upper, high);
                }
            }
            high = lower; // Iterate along the left part
        }
    }

    /**
     * Sorts the specified range of the array using mixed insertion sort.
     *
     * Mixed insertion sort is combination of pin insertion sort,
     * simple insertion sort and pair insertion sort.
     *
     * In the context of Dual-Pivot Quicksort, the pivot element
     * from the left part plays the role of sentinel, because it
     * is less than any elements from the given part. Therefore,
     * expensive check of the left range can be skipped on each
     * iteration unless it is the leftmost call.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param end the index of the last element for simple insertion sort
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void mixedInsertionSort(float[] a, int low, int end, int high) {

        /*
         * Start with pin insertion sort.
         */
        for (int i, p = high; ++low < end && low < p; ) {
            float ai = a[i = low];

            /*
             * Find pin element, smaller than the given element.
             */
            while (ai < a[--p]);

            /*
             * Swap these elements.
             */
            ai = a[p]; a[p] = a[i];

            /*
             * Insert element into sorted part.
             */
            while (ai < a[--i]) {
                a[i + 1] = a[i];
            }
            a[i + 1] = ai;
        }

        /*
         * Continue with simple insertion sort.
         */
        for (int i; low < end; ++low) {
            float ai = a[i = low];

            /*
             * Insert element into sorted part.
             */
            while (ai < a[--i]) {
                a[i + 1] = a[i];
            }
            a[i + 1] = ai;
        }

        /*
         * Finish with pair insertion sort.
         */
        for (int i; low < high; ++low) {
            float a1 = a[i = low], a2 = a[++low];

            /*
             * Insert two elements per iteration: at first, insert the
             * larger element and then insert the smaller element, but
             * from the position where the larger element was inserted.
             */
            if (a1 > a2) {

                while (a1 < a[--i]) {
                    a[i + 2] = a[i];
                }
                a[++i + 1] = a1;

                while (a2 < a[--i]) {
                    a[i + 1] = a[i];
                }
                a[i + 1] = a2;

            } else if (a1 < a[i - 1]) {

                while (a2 < a[--i]) {
                    a[i + 2] = a[i];
                }
                a[++i + 1] = a2;

                while (a1 < a[--i]) {
                    a[i + 1] = a[i];
                }
                a[i + 1] = a1;
            }
        }
    }

    /**
     * Sorts the specified range of the array using insertion sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     * @param leftmost indicates that the range is the leftmost part
     */
    private static void insertionSort(float[] a, int low, int high, boolean leftmost) {
        if (leftmost) {
            for (int i, k = low; ++k < high; ) {
                float ai = a[i = k];

                if (ai < a[i - 1]) {
                    while (--i >= low && ai < a[i]) {
                        a[i + 1] = a[i];
                    }
                    a[i + 1] = ai;
                }
            }
        } else {
            for (int i; ++low < high; ) {
                float ai = a[i = low];

                while (ai < a[--i]) {
                    a[i + 1] = a[i];
                }
                a[i + 1] = ai;
            }
        }
    }

    /**
     * Tries to sort the specified range of the array
     * using LSD (Least Significant Digit) Radix sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     * @return {@code true} if the array is finally sorted, otherwise {@code false}
     */
    static boolean tryRadixSort(Sorter sorter, float[] a, int low, int high) {
        float[] b; int offset = low, size = high - low;

        /*
         * Allocate additional buffer.
         */
        if (sorter != null && (b = (float[]) sorter.b) != null) {
            offset = sorter.offset;
        } else {
            if ((b = (float[]) tryAllocate(a, size)) == null) {
                return false;
            }
        }

        int start = low - offset;
        int last = high - offset;

        /*
         * Count the number of all digits.
         */
        int[] count1 = new int[1024];
        int[] count2 = new int[2048];
        int[] count3 = new int[2048];

        for (int i = low; i < high; ++i) {
            count1[ fti(a[i])         & 0x3FF]--;
            count2[(fti(a[i]) >>> 10) & 0x7FF]--;
            count3[(fti(a[i]) >>> 21) & 0x7FF]--;
        }

        /*
         * Detect digits to be processed.
         */
        boolean processDigit1 = processDigit(count1, 1023, -size, high);
        boolean processDigit2 = processDigit(count2, 2047, -size, high);
        boolean processDigit3 = processDigit(count3, 2047, -size, high);

        /*
         * Process the 1-st digit.
         */
        if (processDigit1) {
            for (int i = low; i < high; ++i) {
                b[count1[fti(a[i]) & 0x3FF]++ - offset] = a[i];
            }
        }

        /*
         * Process the 2-nd digit.
         */
        if (processDigit2) {
            if (processDigit1) {
                for (int i = start; i < last; ++i) {
                    a[count2[(fti(b[i]) >>> 10) & 0x7FF]++] = b[i];
                }
            } else {
                for (int i = low; i < high; ++i) {
                    b[count2[(fti(a[i]) >>> 10) & 0x7FF]++ - offset] = a[i];
                }
            }
        }

        /*
         * Process the 3-rd digit.
         */
        if (processDigit3) {
            if (processDigit1 ^ processDigit2) {
                for (int i = start; i < last; ++i) {
                    a[count3[(fti(b[i]) >>> 21) & 0x7FF]++] = b[i];
                }
            } else {
                for (int i = low; i < high; ++i) {
                    b[count3[(fti(a[i]) >>> 21) & 0x7FF]++ - offset] = a[i];
                }
            }
        }

        /*
         * Copy the buffer to original array, if we process ood number of digits.
         */
        if (processDigit1 ^ processDigit2 ^ processDigit3) {
            System.arraycopy(b, low - offset, a, low, size);
        }
        return true;
    }

    /**
     * Returns masked bits that represent the float number.
     *
     * @param f the given number
     * @return masked bits
     */
    private static int fti(float f) {
        int x = Float.floatToRawIntBits(f);
        return x ^ ((x >> 31) | 0x80000000);
    }

    /**
     * Sorts the specified range of the array using heap sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void heapSort(float[] a, int low, int high) {
        for (int k = (low + high) >>> 1; k > low; ) {
            pushDown(a, --k, a[k], low, high);
        }
        while (--high > low) {
            float max = a[low];
            pushDown(a, low, a[high], low, high);
            a[high] = max;
        }
    }

    /**
     * Pushes specified element down during heap sort.
     *
     * @param a the given array
     * @param p the start index
     * @param value the given element
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void pushDown(float[] a, int p, float value, int low, int high) {
        for (int k ;; a[p] = a[p = k]) {
            k = (p << 1) - low + 2; // Index of the right child

            if (k > high) {
                break;
            }
            if (k == high || a[k] < a[k - 1]) {
                --k;
            }
            if (a[k] <= value) {
                break;
            }
        }
        a[p] = value;
    }

    /**
     * Tries to sort the specified range of the array using merging sort.
     *
     * @param sorter parallel context
     * @param a the array to be sorted
     * @param low the index of the first element to be sorted
     * @param size the array size
     * @return {@code true} if the array is finally sorted, otherwise {@code false}
     */
    private static boolean tryMergingSort(Sorter sorter, float[] a, int low, int size) {

        /*
         * The run array is constructed only if initial runs are
         * long enough to continue, run[i] then holds start index
         * of the i-th sequence of elements in non-descending order.
         */
        int[] run = null;
        int high = low + size;
        int count = 1, last = low;

        /*
         * Identify all possible runs.
         */
        for (int k = low + 1; k < high; ) {

            /*
             * Find the end index of the current run.
             */
            if (a[k - 1] < a[k]) {

                // Identify ascending sequence
                while (++k < high && a[k - 1] <= a[k]);

            } else if (a[k - 1] > a[k]) {

                // Identify descending sequence
                while (++k < high && a[k - 1] >= a[k]);

                // Reverse into ascending order
                for (int i = last - 1, j = k; ++i < --j && a[i] > a[j]; ) {
                    float ai = a[i]; a[i] = a[j]; a[j] = ai;
                }
            } else { // Identify constant sequence
                for (float ak = a[k]; ++k < high && ak == a[k]; );

                if (k < high) {
                    continue;
                }
            }

            /*
             * Check special cases.
             */
            if (run == null) {
                if (k == high) {
                    /*
                     * The array is monotonous sequence,
                     * and therefore already sorted.
                     */
                    return true;
                }

                if (k - low < MIN_FIRST_RUN_SIZE) {
                    /*
                     * The first run is too small
                     * to proceed with scanning.
                     */
                    return false;
                }

                // Initial min 127, max 1023, extended to 5120
                run = new int[((size >> 10) | 0x7F) & 0x3FF];
                run[0] = low;

            } else if (a[last - 1] > a[last]) { // Start new run

                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {
                    /*
                     * The first runs are not long
                     * enough to continue scanning.
                     */
                    return false;
                }

                if (++count == MAX_RUN_CAPACITY) {
                    /*
                     * Array is not highly structured.
                     */
                    return false;
                }

                if (count == run.length) {
                    /*
                     * Increase capacity of index array.
                     */
                    run = Arrays.copyOf(run, count << 1);
                }
            }
            run[count] = (last = k);

            if (++k == high) {
                /*
                 * This is single-element run at the end.
                 */
                --k;
            }
        }

        /*
         * Merge runs of highly structured array.
         */
        if (count > 1) {
            float[] b; int offset = low;

            if (sorter != null && (b = (float[]) sorter.b) != null) {
                offset = sorter.offset;
            } else {
                if ((b = (float[]) tryAllocate(a, size)) == null) {
                    return false;
                }
            }
            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);
        }
        return true;
    }

    /**
     * Merges the specified runs.
     *
     * @param a the source array
     * @param b the temporary buffer used in merging
     * @param offset the start index in the source, inclusive
     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)
     * @param parallel indicates whether merging is performed in parallel
     * @param run the start indexes of the runs, inclusive
     * @param lo the start index of the first run, inclusive
     * @param hi the start index of the last run, inclusive
     * @return the destination where runs are merged
     */
    private static float[] mergeRuns(float[] a, float[] b, int offset,
                                     int aim, boolean parallel, int[] run, int lo, int hi) {

        if (hi - lo == 1) {
            if (aim >= 0) {
                return a;
            }
            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);
            return b;
        }

        /*
         * Split into approximately equal parts.
         */
        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;
        while (run[++mi + 1] <= rmi);

        /*
         * Merge the left and right parts.
         */
        float[] a1, a2;

        if (parallel && hi - lo > MIN_RUN_COUNT) {
            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();
            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);
            a2 = (float[]) merger.getDestination();
        } else {
            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);
            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);
        }

        float[] dst = a1 == a ? b : a;

        int k   = a1 == a ? run[lo] - offset : run[lo];
        int lo1 = a1 == b ? run[lo] - offset : run[lo];
        int hi1 = a1 == b ? run[mi] - offset : run[mi];
        int lo2 = a2 == b ? run[mi] - offset : run[mi];
        int hi2 = a2 == b ? run[hi] - offset : run[hi];

        if (parallel) {
            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();
        } else {
            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);
        }
        return dst;
    }

    /**
     * Merges the sorted parts.
     *
     * @param merger parallel context
     * @param dst the destination where parts are merged
     * @param k the start index of the destination, inclusive
     * @param a1 the first part
     * @param lo1 the start index of the first part, inclusive
     * @param hi1 the end index of the first part, exclusive
     * @param a2 the second part
     * @param lo2 the start index of the second part, inclusive
     * @param hi2 the end index of the second part, exclusive
     */
    private static void mergeParts(Merger merger, float[] dst, int k,
                                   float[] a1, int lo1, int hi1, float[] a2, int lo2, int hi2) {

        if (merger != null && a1 == a2) {

            while (true) {

                /*
                 * The first part must be larger.
                 */
                if (hi1 - lo1 < hi2 - lo2) {
                    int lo = lo1; lo1 = lo2; lo2 = lo;
                    int hi = hi1; hi1 = hi2; hi2 = hi;
                }

                /*
                 * Small parts will be merged sequentially.
                 */
                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {
                    break;
                }

                /*
                 * Find the median of the larger part.
                 */
                int mi1 = (lo1 + hi1) >>> 1;
                float key = a1[mi1];
                int mi2 = hi2;

                /*
                 * Partition the smaller part.
                 */
                for (int loo = lo2; loo < mi2; ) {
                    int t = (loo + mi2) >>> 1;

                    if (key > a2[t]) {
                        loo = t + 1;
                    } else {
                        mi2 = t;
                    }
                }

                /*
                 * Reserve space for the left sub-parts.
                 */
                int d = mi2 - lo2 + mi1 - lo1;

                /*
                 * Merge the right sub-parts in parallel.
                 */
                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);

                /*
                 * Process the sub-left parts.
                 */
                hi1 = mi1;
                hi2 = mi2;
            }
        }

        /*
         * Merge small parts sequentially.
         */
        while (lo1 < hi1 && lo2 < hi2) {
            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];
        }
        if (dst != a1 || k < lo1) {
            while (lo1 < hi1) {
                dst[k++] = a1[lo1++];
            }
        }
        if (dst != a2 || k < lo2) {
            while (lo2 < hi2) {
                dst[k++] = a2[lo2++];
            }
        }
    }

// #[double]

    /**
     * Sorts the specified range of the array using parallel merge
     * sort and/or Dual-Pivot Quicksort.
     *
     * To balance the faster splitting and parallelism of merge sort
     * with the faster element partitioning of Quicksort, ranges are
     * subdivided in tiers such that, if there is enough parallelism,
     * the four-way parallel merge is started, still ensuring enough
     * parallelism to process the partitions.
     *
     * @param a the array to be sorted
     * @param parallelism the parallelism level
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    static void sort(double[] a, int parallelism, int low, int high) {
        /*
         * Phase 1. Count the number of negative zero -0.0d,
         * turn them into positive zero, and move all NaNs
         * to the end of the array.
         */
        int numNegativeZero = 0;

        for (int k = high; k > low; ) {
            double ak = a[--k];

            if (ak == 0.0d && Double.doubleToRawLongBits(ak) < 0) { // ak is -0.0d
                numNegativeZero += 1;
                a[k] = 0.0d;
            } else if (ak != ak) { // ak is NaN
                a[k] = a[--high];
                a[high] = ak;
            }
        }

        /*
         * Phase 2. Sort everything except NaNs,
         * which are already in place.
         */
        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {
            new Sorter(a, parallelism, low, high - low, 0).invoke();
        } else {
            sort(null, a, 0, low, high);
        }

        /*
         * Phase 3. Turn positive zero 0.0d
         * back into negative zero -0.0d.
         */
        if (++numNegativeZero == 1) {
            return;
        }

        /*
         * Find the position one less than
         * the index of the first zero.
         */
        while (low <= high) {
            int middle = (low + high) >>> 1;

            if (a[middle] < 0) {
                low = middle + 1;
            } else {
                high = middle - 1;
            }
        }

        /*
         * Replace the required number of 0.0d by -0.0d.
         */
        while (--numNegativeZero > 0) {
            a[++high] = -0.0d;
        }
    }

    /**
     * Sorts the specified range of the array using Dual-Pivot Quicksort.
     *
     * @param sorter parallel context
     * @param a the array to be sorted
     * @param bits the combination of recursion depth and bit flag, where
     *        the right bit "0" indicates that range is the leftmost part
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    static void sort(Sorter sorter, double[] a, int bits, int low, int high) {
        while (true) {
            int end = high - 1, size = high - low;

            /*
             * Run mixed insertion sort on small non-leftmost parts.
             */
            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {
                mixedInsertionSort(a, low, high - ((size >> 2) << 1), high);
                return;
            }

            /*
             * Invoke insertion sort on small leftmost part.
             */
            if (size < MAX_INSERTION_SORT_SIZE) {
                insertionSort(a, low, high, (bits & 1) == 0);
                return;
            }

            /*
             * Check if the whole array or large non-leftmost
             * parts are nearly sorted and then merge runs.
             */
            if ((bits == 0 || size > MIN_MERGING_SORT_SIZE && (bits & 1) > 0)
                    && tryMergingSort(sorter, a, low, size)) {
                return;
            }

            /*
             * Switch to heap sort, if execution time is quadratic.
             */
            if ((bits += DEPTH) > MAX_RECURSION_DEPTH) {
                heapSort(a, low, high);
                return;
            }

            /*
             * Use an inexpensive approximation of the golden ratio
             * to select five sample elements and determine pivots.
             */
            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;

            /*
             * Five elements around (and including) the central element
             * will be used for pivot selection as described below. The
             * unequal choice of spacing these elements was empirically
             * determined to work well on a wide variety of inputs.
             */
            int e1 = low + step;
            int e5 = end - step;
            int e3 = (e1 + e5) >>> 1;
            int e2 = (e1 + e3) >>> 1;
            int e4 = (e3 + e5) >>> 1;
            double a3 = a[e3];

            boolean isRandom =
                    a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5];

            /*
             * Sort these elements in place by the combination
             * of 4-element sorting network and insertion sort.
             *
             *    1  ------------o-----o------------
             *                   |     |
             *    2  ------o-----|-----o-----o------
             *             |     |           |
             *    4  ------|-----o-----o-----o------
             *             |           |
             *    5  ------o-----------o------------
             */
            if (a[e2] > a[e5]) { double t = a[e2]; a[e2] = a[e5]; a[e5] = t; }
            if (a[e1] > a[e4]) { double t = a[e1]; a[e1] = a[e4]; a[e4] = t; }
            if (a[e1] > a[e2]) { double t = a[e1]; a[e1] = a[e2]; a[e2] = t; }
            if (a[e4] > a[e5]) { double t = a[e4]; a[e4] = a[e5]; a[e5] = t; }
            if (a[e2] > a[e4]) { double t = a[e2]; a[e2] = a[e4]; a[e4] = t; }

            /*
             * Insert the third element.
             */
            if (a3 < a[e2]) {
                if (a3 < a[e1]) {
                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;
                } else {
                    a[e3] = a[e2]; a[e2] = a3;
                }
            } else if (a3 > a[e4]) {
                if (a3 > a[e5]) {
                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;
                } else {
                    a[e3] = a[e4]; a[e4] = a3;
                }
            }

            /*
             * Try Radix sort on large fully random data,
             * taking into account parallel context.
             */
            if (size > MIN_RADIX_SORT_SIZE
                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5] && isRandom
                    && (sorter == null || bits > MIN_RADIX_SORT_DEPTH)
                    && tryRadixSort(sorter, a, low, high)) {
                return;
            }

            // Pointers
            int lower = low; // The index of the last element of the left part
            int upper = end; // The index of the first element of the right part

            /*
             * Partitioning with two pivots on array of random elements.
             */
            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {

                /*
                 * Use the first and fifth of the five sorted elements as
                 * the pivots. These values are inexpensive approximation
                 * of tertiles. Note, that pivot1 < pivot2.
                 */
                double pivot1 = a[e1];
                double pivot2 = a[e5];

                /*
                 * The first and the last elements to be sorted are moved
                 * to the locations formerly occupied by the pivots. When
                 * partitioning is completed, the pivots are swapped back
                 * into their final positions, and excluded from the next
                 * subsequent sorting.
                 */
                a[e1] = a[lower];
                a[e5] = a[upper];

                /*
                 * Skip elements, which are less or greater than the pivots.
                 */
                while (a[++lower] < pivot1);
                while (a[--upper] > pivot2);

                /*
                 * Backward 3-interval partitioning
                 *
                 *     left part                    central part          right part
                 * +------------------------------------------------------------------+
                 * |   < pivot1   |    ?    |  pivot1 <= && <= pivot2  |   > pivot2   |
                 * +------------------------------------------------------------------+
                 *               ^         ^                            ^
                 *               |         |                            |
                 *             lower       k                          upper
                 *
                 * Pointer k is the last index of ?-part
                 * Pointer lower is the last index of left part
                 * Pointer upper is the first index of right part
                 *
                 * Invariants:
                 *
                 *     all in (low, lower]  <  pivot1
                 *     all in (k, upper)   in [pivot1, pivot2]
                 *     all in [upper, end)  >  pivot2
                 */
                for (int unused = --lower, k = ++upper; --k > lower; ) {
                    double ak = a[k];

                    if (ak < pivot1) { // Move a[k] to the left side
                        while (a[++lower] < pivot1) {
                            if (lower == k) {
                                break;
                            }
                        }
                        if (a[lower] > pivot2) {
                            a[k] = a[--upper];
                            a[upper] = a[lower];
                        } else {
                            a[k] = a[lower];
                        }
                        a[lower] = ak;
                    } else if (ak > pivot2) { // Move a[k] to the right side
                        a[k] = a[--upper];
                        a[upper] = ak;
                    }
                }

                /*
                 * Swap the pivots into their final positions.
                 */
                a[low] = a[lower]; a[lower] = pivot1;
                a[end] = a[upper]; a[upper] = pivot2;

                /*
                 * Sort non-left parts recursively (possibly in parallel),
                 * excluding known pivots.
                 */
                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {
                    sorter.forkSorter(bits | 1, lower + 1, upper);
                    sorter.forkSorter(bits | 1, upper + 1, high);
                } else {
                    sort(sorter, a, bits | 1, lower + 1, upper);
                    sort(sorter, a, bits | 1, upper + 1, high);
                }

            } else { // Partitioning with one pivot

                /*
                 * Use the third of the five sorted elements as the pivot.
                 * This value is inexpensive approximation of the median.
                 */
                double pivot = a[e3];

                /*
                 * The first element to be sorted is moved to the
                 * location formerly occupied by the pivot. After
                 * completion of partitioning the pivot is swapped
                 * back into its final position, and excluded from
                 * the next subsequent sorting.
                 */
                a[e3] = a[lower];

                /*
                 * Dutch National Flag partitioning
                 *
                 *    left part                central part    right part
                 * +------------------------------------------------------+
                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |
                 * +------------------------------------------------------+
                 *              ^           ^                ^
                 *              |           |                |
                 *            lower         k              upper
                 *
                 * Pointer k is the last index of ?-part
                 * Pointer lower is the last index of left part
                 * Pointer upper is the first index of right part
                 *
                 * Invariants:
                 *
                 *     all in (low, lower]  <  pivot
                 *     all in (k, upper)   ==  pivot
                 *     all in [upper, end]  >  pivot
                 */
                for (int k = ++upper; --k > lower; ) {
                    double ak = a[k];

                    if (ak != pivot) {
                        a[k] = pivot;

                        if (ak < pivot) { // Move a[k] to the left side
                            while (a[++lower] < pivot);

                            if (a[lower] > pivot) {
                                a[--upper] = a[lower];
                            }
                            a[lower] = ak;
                        } else { // ak > pivot - Move a[k] to the right side
                            a[--upper] = ak;
                        }
                    }
                }

                /*
                 * Swap the pivot into its final position.
                 */
                a[low] = a[lower]; a[lower] = pivot;

                /*
                 * Sort the right part (possibly in parallel), excluding
                 * known pivot. All elements from the central part are
                 * equal and therefore already sorted.
                 */
                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {
                    sorter.forkSorter(bits | 1, upper, high);
                } else {
                    sort(sorter, a, bits | 1, upper, high);
                }
            }
            high = lower; // Iterate along the left part
        }
    }

    /**
     * Sorts the specified range of the array using mixed insertion sort.
     *
     * Mixed insertion sort is combination of pin insertion sort,
     * simple insertion sort and pair insertion sort.
     *
     * In the context of Dual-Pivot Quicksort, the pivot element
     * from the left part plays the role of sentinel, because it
     * is less than any elements from the given part. Therefore,
     * expensive check of the left range can be skipped on each
     * iteration unless it is the leftmost call.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param end the index of the last element for simple insertion sort
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void mixedInsertionSort(double[] a, int low, int end, int high) {

        /*
         * Start with pin insertion sort.
         */
        for (int i, p = high; ++low < end && low < p; ) {
            double ai = a[i = low];

            /*
             * Find pin element, smaller than the given element.
             */
            while (ai < a[--p]);

            /*
             * Swap these elements.
             */
            ai = a[p]; a[p] = a[i];

            /*
             * Insert element into sorted part.
             */
            while (ai < a[--i]) {
                a[i + 1] = a[i];
            }
            a[i + 1] = ai;
        }

        /*
         * Continue with simple insertion sort.
         */
        for (int i; low < end; ++low) {
            double ai = a[i = low];

            /*
             * Insert element into sorted part.
             */
            while (ai < a[--i]) {
                a[i + 1] = a[i];
            }
            a[i + 1] = ai;
        }

        /*
         * Finish with pair insertion sort.
         */
        for (int i; low < high; ++low) {
            double a1 = a[i = low], a2 = a[++low];

            /*
             * Insert two elements per iteration: at first, insert the
             * larger element and then insert the smaller element, but
             * from the position where the larger element was inserted.
             */
            if (a1 > a2) {

                while (a1 < a[--i]) {
                    a[i + 2] = a[i];
                }
                a[++i + 1] = a1;

                while (a2 < a[--i]) {
                    a[i + 1] = a[i];
                }
                a[i + 1] = a2;

            } else if (a1 < a[i - 1]) {

                while (a2 < a[--i]) {
                    a[i + 2] = a[i];
                }
                a[++i + 1] = a2;

                while (a1 < a[--i]) {
                    a[i + 1] = a[i];
                }
                a[i + 1] = a1;
            }
        }
    }

    /**
     * Sorts the specified range of the array using insertion sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     * @param leftmost indicates that the range is the leftmost part
     */
    private static void insertionSort(double[] a, int low, int high, boolean leftmost) {
        if (leftmost) {
            for (int i, k = low; ++k < high; ) {
                double ai = a[i = k];

                if (ai < a[i - 1]) {
                    while (--i >= low && ai < a[i]) {
                        a[i + 1] = a[i];
                    }
                    a[i + 1] = ai;
                }
            }
        } else {
            for (int i; ++low < high; ) {
                double ai = a[i = low];

                while (ai < a[--i]) {
                    a[i + 1] = a[i];
                }
                a[i + 1] = ai;
            }
        }
    }

    /**
     * Tries to sort the specified range of the array
     * using LSD (Least Significant Digit) Radix sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     * @return {@code true} if the array is finally sorted, otherwise {@code false}
     */
    static boolean tryRadixSort(Sorter sorter, double[] a, int low, int high) {
        double[] b; int offset = low, size = high - low;

        /*
         * Allocate additional buffer.
         */
        if (sorter != null && (b = (double[]) sorter.b) != null) {
            offset = sorter.offset;
        } else {
            if ((b = (double[]) tryAllocate(a, size)) == null) {
                return false;
            }
        }

        int start = low - offset;
        int last = high - offset;

        /*
         * Count the number of all digits.
         */
        int[] count1 = new int[1024];
        int[] count2 = new int[2048];
        int[] count3 = new int[2048];
        int[] count4 = new int[2048];
        int[] count5 = new int[2048];
        int[] count6 = new int[1024];

        for (int i = low; i < high; ++i) {
            count1[(int)  (dtl(a[i])         & 0x3FF)]--;
            count2[(int) ((dtl(a[i]) >>> 10) & 0x7FF)]--;
            count3[(int) ((dtl(a[i]) >>> 21) & 0x7FF)]--;
            count4[(int) ((dtl(a[i]) >>> 32) & 0x7FF)]--;
            count5[(int) ((dtl(a[i]) >>> 43) & 0x7FF)]--;
            count6[(int) ((dtl(a[i]) >>> 54) & 0x3FF)]--;
        }

        /*
         * Detect digits to be processed.
         */
        boolean processDigit1 = processDigit(count1, 1023, -size, high);
        boolean processDigit2 = processDigit(count2, 2047, -size, high);
        boolean processDigit3 = processDigit(count3, 2047, -size, high);
        boolean processDigit4 = processDigit(count4, 2047, -size, high);
        boolean processDigit5 = processDigit(count5, 2047, -size, high);
        boolean processDigit6 = processDigit(count6, 1023, -size, high);

        /*
         * Process the 1-st digit.
         */
        if (processDigit1) {
            for (int i = low; i < high; ++i) {
                b[count1[(int) (dtl(a[i]) & 0x3FF)]++ - offset] = a[i];
            }
        }

        /*
         * Process the 2-nd digit.
         */
        if (processDigit2) {
            if (processDigit1) {
                for (int i = start; i < last; ++i) {
                    a[count2[(int) ((dtl(b[i]) >>> 10) & 0x7FF)]++] = b[i];
                }
            } else {
                for (int i = low; i < high; ++i) {
                    b[count2[(int) ((dtl(a[i]) >>> 10) & 0x7FF)]++ - offset] = a[i];
                }
            }
        }

        /*
         * Process the 3-rd digit.
         */
        if (processDigit3) {
            if (processDigit1 ^ processDigit2) {
                for (int i = start; i < last; ++i) {
                    a[count3[(int) ((dtl(b[i]) >>> 21) & 0x7FF)]++] = b[i];
                }
            } else {
                for (int i = low; i < high; ++i) {
                    b[count3[(int) ((dtl(a[i]) >>> 21) & 0x7FF)]++ - offset] = a[i];
                }
            }
        }

        /*
         * Process the 4-th digit.
         */
        if (processDigit4) {
            if (processDigit1 ^ processDigit2 ^ processDigit3) {
                for (int i = start; i < last; ++i) {
                    a[count4[(int) ((dtl(b[i]) >>> 32) & 0x7FF)]++] = b[i];
                }
            } else {
                for (int i = low; i < high; ++i) {
                    b[count4[(int) ((dtl(a[i]) >>> 32) & 0x7FF)]++ - offset] = a[i];
                }
            }
        }

        /*
         * Process the 5-th digit.
         */
        if (processDigit5) {
            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {
                for (int i = start; i < last; ++i) {
                    a[count5[(int) ((dtl(b[i]) >>> 43) & 0x7FF)]++] = b[i];
                }
            } else {
                for (int i = low; i < high; ++i) {
                    b[count5[(int) ((dtl(a[i]) >>> 43) & 0x7FF)]++ - offset] = a[i];
                }
            }
        }

        /*
         * Process the 6-th digit.
         */
        if (processDigit6) {
            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {
                for (int i = start; i < last; ++i) {
                    a[count6[(int) ((dtl(b[i]) >>> 54) & 0x3FF)]++] = b[i];
                }
            } else {
                for (int i = low; i < high; ++i) {
                    b[count6[(int) ((dtl(a[i]) >>> 54) & 0x3FF)]++ - offset] = a[i];
                }
            }
        }

        /*
         * Copy the buffer to original array, if we process ood number of digits.
         */
        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {
            System.arraycopy(b, low - offset, a, low, size);
        }
        return true;
    }

    /**
     * Returns masked bits that represent the double number.
     *
     *
     * @return masked bits
     */
    private static long dtl(double d) {
        long x = Double.doubleToRawLongBits(d);
        return x ^ ((x >> 63) | 0x8000000000000000L);
    }

    /**
     * Sorts the specified range of the array using heap sort.
     *
     * @param a the array to be sorted
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void heapSort(double[] a, int low, int high) {
        for (int k = (low + high) >>> 1; k > low; ) {
            pushDown(a, --k, a[k], low, high);
        }
        while (--high > low) {
            double max = a[low];
            pushDown(a, low, a[high], low, high);
            a[high] = max;
        }
    }

    /**
     * Pushes specified element down during heap sort.
     *
     * @param a the given array
     * @param p the start index
     * @param value the given element
     * @param low the index of the first element, inclusive, to be sorted
     * @param high the index of the last element, exclusive, to be sorted
     */
    private static void pushDown(double[] a, int p, double value, int low, int high) {
        for (int k ;; a[p] = a[p = k]) {
            k = (p << 1) - low + 2; // Index of the right child

            if (k > high) {
                break;
            }
            if (k == high || a[k] < a[k - 1]) {
                --k;
            }
            if (a[k] <= value) {
                break;
            }
        }
        a[p] = value;
    }

    /**
     * Tries to sort the specified range of the array using merging sort.
     *
     * @param sorter parallel context
     * @param a the array to be sorted
     * @param low the index of the first element to be sorted
     * @param size the array size
     * @return {@code true} if the array is finally sorted, otherwise {@code false}
     */
    private static boolean tryMergingSort(Sorter sorter, double[] a, int low, int size) {

        /*
         * The run array is constructed only if initial runs are
         * long enough to continue, run[i] then holds start index
         * of the i-th sequence of elements in non-descending order.
         */
        int[] run = null;
        int high = low + size;
        int count = 1, last = low;

        /*
         * Identify all possible runs.
         */
        for (int k = low + 1; k < high; ) {

            /*
             * Find the end index of the current run.
             */
            if (a[k - 1] < a[k]) {

                // Identify ascending sequence
                while (++k < high && a[k - 1] <= a[k]);

            } else if (a[k - 1] > a[k]) {

                // Identify descending sequence
                while (++k < high && a[k - 1] >= a[k]);

                // Reverse into ascending order
                for (int i = last - 1, j = k; ++i < --j && a[i] > a[j]; ) {
                    double ai = a[i]; a[i] = a[j]; a[j] = ai;
                }
            } else { // Identify constant sequence
                for (double ak = a[k]; ++k < high && ak == a[k]; );

                if (k < high) {
                    continue;
                }
            }

            /*
             * Check special cases.
             */
            if (run == null) {
                if (k == high) {
                    /*
                     * The array is monotonous sequence,
                     * and therefore already sorted.
                     */
                    return true;
                }

                if (k - low < MIN_FIRST_RUN_SIZE) {
                    /*
                     * The first run is too small
                     * to proceed with scanning.
                     */
                    return false;
                }

                // Initial min 127, max 1023, extended to 5120
                run = new int[((size >> 10) | 0x7F) & 0x3FF];
                run[0] = low;

            } else if (a[last - 1] > a[last]) { // Start new run

                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {
                    /*
                     * The first runs are not long
                     * enough to continue scanning.
                     */
                    return false;
                }

                if (++count == MAX_RUN_CAPACITY) {
                    /*
                     * Array is not highly structured.
                     */
                    return false;
                }

                if (count == run.length) {
                    /*
                     * Increase capacity of index array.
                     */
                    run = Arrays.copyOf(run, count << 1);
                }
            }
            run[count] = (last = k);

            if (++k == high) {
                /*
                 * This is single-element run at the end.
                 */
                --k;
            }
        }

        /*
         * Merge runs of highly structured array.
         */
        if (count > 1) {
            double[] b; int offset = low;

            if (sorter != null && (b = (double[]) sorter.b) != null) {
                offset = sorter.offset;
            } else {
                if ((b = (double[]) tryAllocate(a, size)) == null) {
                    return false;
                }
            }
            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);
        }
        return true;
    }

    /**
     * Merges the specified runs.
     *
     * @param a the source array
     * @param b the temporary buffer used in merging
     * @param offset the start index in the source, inclusive
     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)
     * @param parallel indicates whether merging is performed in parallel
     * @param run the start indexes of the runs, inclusive
     * @param lo the start index of the first run, inclusive
     * @param hi the start index of the last run, inclusive
     * @return the destination where runs are merged
     */
    private static double[] mergeRuns(double[] a, double[] b, int offset,
                                      int aim, boolean parallel, int[] run, int lo, int hi) {

        if (hi - lo == 1) {
            if (aim >= 0) {
                return a;
            }
            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);
            return b;
        }

        /*
         * Split into approximately equal parts.
         */
        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;
        while (run[++mi + 1] <= rmi);

        /*
         * Merge the left and right parts.
         */
        double[] a1, a2;

        if (parallel && hi - lo > MIN_RUN_COUNT) {
            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();
            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);
            a2 = (double[]) merger.getDestination();
        } else {
            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);
            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);
        }

        double[] dst = a1 == a ? b : a;

        int k   = a1 == a ? run[lo] - offset : run[lo];
        int lo1 = a1 == b ? run[lo] - offset : run[lo];
        int hi1 = a1 == b ? run[mi] - offset : run[mi];
        int lo2 = a2 == b ? run[mi] - offset : run[mi];
        int hi2 = a2 == b ? run[hi] - offset : run[hi];

        if (parallel) {
            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();
        } else {
            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);
        }
        return dst;
    }

    /**
     * Merges the sorted parts.
     *
     * @param merger parallel context
     * @param dst the destination where parts are merged
     * @param k the start index of the destination, inclusive
     * @param a1 the first part
     * @param lo1 the start index of the first part, inclusive
     * @param hi1 the end index of the first part, exclusive
     * @param a2 the second part
     * @param lo2 the start index of the second part, inclusive
     * @param hi2 the end index of the second part, exclusive
     */
    private static void mergeParts(Merger merger, double[] dst, int k,
                                   double[] a1, int lo1, int hi1, double[] a2, int lo2, int hi2) {

        if (merger != null && a1 == a2) {

            while (true) {

                /*
                 * The first part must be larger.
                 */
                if (hi1 - lo1 < hi2 - lo2) {
                    int lo = lo1; lo1 = lo2; lo2 = lo;
                    int hi = hi1; hi1 = hi2; hi2 = hi;
                }

                /*
                 * Small parts will be merged sequentially.
                 */
                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {
                    break;
                }

                /*
                 * Find the median of the larger part.
                 */
                int mi1 = (lo1 + hi1) >>> 1;
                double key = a1[mi1];
                int mi2 = hi2;

                /*
                 * Partition the smaller part.
                 */
                for (int loo = lo2; loo < mi2; ) {
                    int t = (loo + mi2) >>> 1;

                    if (key > a2[t]) {
                        loo = t + 1;
                    } else {
                        mi2 = t;
                    }
                }

                /*
                 * Reserve space for the left sub-parts.
                 */
                int d = mi2 - lo2 + mi1 - lo1;

                /*
                 * Merge the right sub-parts in parallel.
                 */
                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);

                /*
                 * Process the sub-left parts.
                 */
                hi1 = mi1;
                hi2 = mi2;
            }
        }

        /*
         * Merge small parts sequentially.
         */
        while (lo1 < hi1 && lo2 < hi2) {
            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];
        }
        if (dst != a1 || k < lo1) {
            while (lo1 < hi1) {
                dst[k++] = a1[lo1++];
            }
        }
        if (dst != a2 || k < lo2) {
            while (lo2 < hi2) {
                dst[k++] = a2[lo2++];
            }
        }
    }

// #[class]

    /**
     * This class implements parallel sorting.
     */
    private static final class Sorter extends CountedCompleter<Void> {
        private static final long serialVersionUID = 123456789L;

        @SuppressWarnings("serial")
        private final Object a, b;
        private final int low, size, offset, depth;

        private Sorter(Object a, int parallelism, int low, int size, int depth) {
            this.a = a;
            this.low = low;
            this.size = size;
            this.offset = low;

            while ((parallelism >>= 1) > 0 && (size >>= 8) > 0) {
                depth -= 2;
            }
            this.b = depth == 0 ? null : tryAllocate(a, this.size);
            this.depth = b == null ? 0 : depth;
        }

        private Sorter(CountedCompleter<?> parent,
                       Object a, Object b, int low, int size, int offset, int depth) {
            super(parent);
            this.a = a;
            this.b = b;
            this.low = low;
            this.size = size;
            this.offset = offset;
            this.depth = depth;
        }

        @Override
        public final void compute() {
            if (depth < 0) {
                setPendingCount(2);
                int half = size >> 1;
                new Sorter(this, b, a, low, half, offset, depth + 1).fork();
                new Sorter(this, b, a, low + half, size - half, offset, depth + 1).compute();
            } else {
                if (a instanceof int[]) {
                    sort(this, (int[]) a, depth, low, low + size);
                } else if (a instanceof long[]) {
                    sort(this, (long[]) a, depth, low, low + size);
                } else if (a instanceof float[]) {
                    sort(this, (float[]) a, depth, low, low + size);
                } else if (a instanceof double[]) {
                    sort(this, (double[]) a, depth, low, low + size);
                } else {
                    throw new IllegalArgumentException("Unknown array: " + a.getClass().getName());
                }
            }
            tryComplete();
        }

        @Override
        public final void onCompletion(CountedCompleter<?> caller) {
            if (depth < 0) {
                int mi = low + (size >> 1);
                boolean src = (depth & 1) == 0;

                new Merger(null,
                        a,
                        src ? low : low - offset,
                        b,
                        src ? low - offset : low,
                        src ? mi - offset : mi,
                        b,
                        src ? mi - offset : mi,
                        src ? low + size - offset : low + size
                ).invoke();
            }
        }

        private void forkSorter(int depth, int low, int high) {
            addToPendingCount(1);
            new Sorter(this, a, b, low, high - low, offset, depth).fork();
        }
    }

    /**
     * This class implements parallel merging.
     */
    private static final class Merger extends CountedCompleter<Void> {
        private static final long serialVersionUID = 123456789L;

        @SuppressWarnings("serial")
        private final Object dst, a1, a2;
        private final int k, lo1, hi1, lo2, hi2;

        private Merger(CountedCompleter<?> parent, Object dst, int k,
                       Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {
            super(parent);
            this.dst = dst;
            this.k = k;
            this.a1 = a1;
            this.lo1 = lo1;
            this.hi1 = hi1;
            this.a2 = a2;
            this.lo2 = lo2;
            this.hi2 = hi2;
        }

        @Override
        public final void compute() {
            if (dst instanceof int[]) {
                mergeParts(this, (int[]) dst, k,
                        (int[]) a1, lo1, hi1, (int[]) a2, lo2, hi2);
            } else if (dst instanceof long[]) {
                mergeParts(this, (long[]) dst, k,
                        (long[]) a1, lo1, hi1, (long[]) a2, lo2, hi2);
            } else if (dst instanceof float[]) {
                mergeParts(this, (float[]) dst, k,
                        (float[]) a1, lo1, hi1, (float[]) a2, lo2, hi2);
            } else if (dst instanceof double[]) {
                mergeParts(this, (double[]) dst, k,
                        (double[]) a1, lo1, hi1, (double[]) a2, lo2, hi2);
            } else {
                throw new IllegalArgumentException("Unknown array: " + dst.getClass().getName());
            }
            propagateCompletion();
        }

        private void forkMerger(Object dst, int k,
                                Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {
            addToPendingCount(1);
            new Merger(this, dst, k, a1, lo1, hi1, a2, lo2, hi2).fork();
        }
    }

    /**
     * This class implements parallel merging of runs.
     */
    private static final class RunMerger extends RecursiveTask<Object> {
        private static final long serialVersionUID = 123456789L;

        @SuppressWarnings("serial")
        private final Object a, b;
        private final int[] run;
        private final int offset, aim, lo, hi;

        private RunMerger(Object a, Object b, int offset,
                          int aim, int[] run, int lo, int hi) {
            this.a = a;
            this.b = b;
            this.offset = offset;
            this.aim = aim;
            this.run = run;
            this.lo = lo;
            this.hi = hi;
        }

        @Override
        protected final Object compute() {
            if (a instanceof int[]) {
                return mergeRuns((int[]) a, (int[]) b, offset, aim, true, run, lo, hi);
            }
            if (a instanceof long[]) {
                return mergeRuns((long[]) a, (long[]) b, offset, aim, true, run, lo, hi);
            }
            if (a instanceof float[]) {
                return mergeRuns((float[]) a, (float[]) b, offset, aim, true, run, lo, hi);
            }
            if (a instanceof double[]) {
                return mergeRuns((double[]) a, (double[]) b, offset, aim, true, run, lo, hi);
            }
            throw new IllegalArgumentException("Unknown array: " + a.getClass().getName());
        }

        private RunMerger forkMe() {
            fork();
            return this;
        }

        private Object getDestination() {
            join();
            return getRawResult();
        }
    }

    /**
     * Tries to allocate memory for additional buffer.
     *
     * @param a the array of given type
     * @param length the additional buffer length
     * @return {@code null} if requested length is too large, otherwise created buffer
     */
    public static Object tryAllocate(Object a, int length) {
        if (length > MAX_BUFFER_LENGTH) {
            return null;
        }
        try {
            if (a instanceof int[]) {
                return new int[length];
            }
            if (a instanceof long[]) {
                return new long[length];
            }
            if (a instanceof float[]) {
                return new float[length];
            }
            if (a instanceof double[]) {
                return new double[length];
            }
            throw new IllegalArgumentException("Unknown array: " + a.getClass().getName());
        } catch (OutOfMemoryError e) {
            return null;
        }
    }
}
